{
  "language": "Angular",
  "documentationUrl": "https://angular.io/docs",
  "snippets": [
    {
      "title": "Angular Starter",
      "fileName": "app.component",
      "fileType": ".ts",
      "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'Angular Starter';\n  count = 0;\n\n  increment() {\n    this.count++;\n  }\n\n  decrement() {\n    this.count--;\n  }\n}",
      "description": "In comparison to other frameworks, Angular establishes several clear distinctions: in exchange for its reliability and consistency, Angular is more opinionated, prescriptive, and structured. \n\n Because of these characteristics, Angular's learning curve tends to be steeper and development can be less agile than with other frameworks, but Angular rewards developers with consistent, sturdy and finely structured environments. If you find yourself constantly developing small applications, Angular is still a good choice for several reasons, the most notable being it's strong typing through TypeScript, and well defined ecosystems with a visible path towards scalability.  \n\n### Key Features:\n- **Component-Based Architecture**: Angular applications are built using components, which encapsulate the logic and view of a part of the application.\n- **Dependency Injection**: Angular uses dependency injection to manage services and components, making it easier to develop and test applications.\n- **Two-Way Data Binding**: Angular provides two-way data binding, allowing automatic synchronization between the model and the view.\n- **TypeScript**: Angular is built with TypeScript, which adds static typing to JavaScript, improving code quality and maintainability."
    },
    {
      "title":"Modules or Components?",
      "fileName":"app.module",
      "fileType":".ts",
      "code":"import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}",
      "description":"Angular applications are modular, meaning they are built using modules. A module is a container for a cohesive block of code dedicated to an application domain, a workflow, or a closely related set of capabilities. \n\n In Angular, every application has at least one module, the root module, which is conventionally named AppModule. The root module is the entry point to launch the application. \n\n You can also create feature modules to organize your code into cohesive blocks of functionality. Feature modules can be lazy-loaded to improve performance. Latest Angular versions also support the concept of standalone components, which can be used without being declared in a module. \n\n In this example, we define a root module called AppModule that imports the BrowserModule and declares the AppComponent. The AppComponent is the root component of the application. \n\n Depending on the size of your application, you may want to create feature modules to organize your code into cohesive blocks of functionality. Feature modules can be lazy-loaded to improve performance."
    },
    {
      "title":"A module for routing",
      "fileName":"app-routing.module",
      "fileType":".ts",
      "code":"import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { AboutComponent } from './about/about.component';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}",
      "description":"Routing is a powerful feature of Angular that allows you to navigate between different views or components in your application. The Angular Router enables navigation from one view to the next as users perform application tasks. \n\n By implementing a module specifically for routing, you can keep your routing logic separate from your application logic. This is especially useful in larger applications where you may have multiple routes and components. \n\n As added bonuses, you can also apply certain logics to your routes, such as guards, resolvers, and lazy loading."      
    },
    {
      "title": "Services and Dependency Injection",
      "fileName": "app.service",
      "fileType": ".ts",
      "code": "import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AppService {\n  getData() {\n    return 'Hello from AppService!';\n  }\n}",
      "description": "Services are a way to share data and functionality across components in Angular. They are typically used for data access, business logic, and other reusable functionality. \n\n Angular uses dependency injection to provide services to components. This means that you can inject a service into a component's constructor and use it without having to create an instance of the service yourself. \n\n You do this by using the `@Injectable` decorator, which marks a class as available to be provided and injected as a dependency. Inside the decorator, you can specify the `providedIn` property to define the scope of the service. In this case, we are providing the service at the root level, which means it will be available throughout the application. \n\n In this example, we create a simple service called AppService that has a method called getData. This method returns a string. You can inject this service into any component and use it to access the data or functionality provided by the service. \n\n Since we are using a global application service, we take the liberty of appending the `App` prefix to the service name. This is a common convention in Angular applications to avoid naming conflicts and to indicate that the service is part of the application. For example, if you have a service that fetches data from an API, you might name it `ApiService` or `DataService` with a corresponding filename such as `api.service.ts` or `data.service.ts`. Or you can also make it more specific, like `UserService` or `ProductService`, depending on the data it handles, while also throwing everything into a `services` folder. "
    },
    {
      "title": "Components",
      "fileName": "mycomponent.component",
      "fileType": ".html",
      "code": "<h1>{{ title }}</h1>\n<button (click)=\"increment()\">Increment</button>\n<button (click)=\"decrement()\">Decrement</button>\n<p>Count: {{ count }}</p>",
      "description": "Components are the building blocks of Angular applications. Each component is a self-contained unit that encapsulates its own logic, view, and styles. Components can be reused throughout the application, making it easy to create complex UIs by composing simple components together. \n\n Angular components are a bit different from React/Vue components. Angular usually encourages the separation of logic and view, meaning that you will usually have a separate HTML file for the template and a separate CSS file for the styles. \n\n What you are looking at here, is a simple html template file that would be used in conjunction with a corresponding `.component.ts` file. Refer to the next snippet for more details."
    },
    {
      "title": "Components Pt. 2",
      "fileName": "mycomponent.component",
      "fileType": ".ts",
      "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-mycomponent',\n  templateUrl: './mycomponent.component.html',\n  styleUrls: ['./mycomponent.component.css']\n})\nexport class MyComponent {\n  title = 'My Component';\n  count = 0;\n\n  increment() {\n    this.count++;\n  }\n\n  decrement() {\n    this.count--;\n  }\n}",
      "description": "\nThis is the TypeScript file for the component. It defines the component's logic and properties. The `@Component` decorator is used to define the component's metadata, including its selector, template URL, and style URLs. \n\n The `selector` property defines the custom HTML tag that will be used to render the component in the template. The `templateUrl` property specifies the path to the HTML file that contains the component's template. The `styleUrls` property specifies the path to the CSS file that contains the component's styles. \n\n In this example, we create a simple component called MyComponent that has a title and a count property. The increment and decrement methods are used to update the count property when the buttons are clicked."
    },
    {
      "title":"Modules",
      "fileName":"mycomponent.module",
      "fileType":".ts",
      "code":"import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { MyComponent } from './mycomponent.component';\n\n@NgModule({\n  declarations: [MyComponent],\n  imports: [CommonModule],\n  exports: [MyComponent]\n})\nexport class MyComponentModule {}",
      "description":"# Reuse through modules\n\n In Angular, you can create reusable modules that encapsulate components, directives, and pipes. This allows you to organize your code into cohesive blocks of functionality that can be easily reused across different parts of your application. \n\n The idea is that you can create a module that contains all the components, directives, and pipes that are related to a specific feature or functionality, as well as importing any necessary Angular modules that contain functionalities you may need in this specific module, or export any components, directives, or pipes that you want to make available to other modules. \n\n ## Declarations \n\n The `declarations` property is an array of components, directives, and pipes that belong to this module. You must declare all components, directives, and pipes that are used in the templates of the components that belong to this module. \n\n Declared elements are only available to the components, directives, and pipes that are declared in the same module. \n\n ## Imports \n\n The `imports` property is an array of other modules that this module depends on. You can import any Angular module or a custom module that you have created. You are allowed to import standalone components as well. However, you cannot import a module that is not declared in the same module. You are also encouraged to import whole modules instead of individual components due to the way Angular handles tree-shaking. \n\n ### CommonModule \n\n  You generally are also encouraged to import the `CommonModule` in your feature modules, as it contains common directives such as `ngIf` and `ngFor`, which are used in most Angular applications. \n\n ## Exports \n\n The `exports` property is an array of components, directives, and pipes that you want to make available to other modules. You can export any component, directive, or pipe that is declared in this module. This allows you to reuse the components, directives, and pipes in other modules without having to declare them again. \n\n ### But why?\n\n The reason for this is that Angular uses a hierarchical dependency injection system, which means that each module has its own injector. When you import a module, you are creating a new injector for that module. If you want to use a component, directive, or pipe from another module, you need to export it from that module so that it can be used in the new injector. Doing this helps to avoid naming conflicts by keeping as much data as organized as possible, while also avoiding circular dependencies. \n\n ## Circular what? \n\n Circular dependencies occur when two or more modules depend on each other, creating a loop. This can lead to issues with dependency injection and can make your code harder to maintain. By using feature modules and exporting components, directives, and pipes, you can avoid circular dependencies and keep your code organized. In the case that you still need to import a module that is already imported in another module, you can use the `forwardRef` function in the decorator to create a circular reference. However, this is not recommended and should be avoided if possible. \n\n ## Conclusion \n\n In this example, we create a simple module called MyComponentModule that declares the MyComponent component and imports the CommonModule. We also export the MyComponent component so that it can be used in other modules. This allows us to reuse the MyComponent component in other parts of the application without having to declare it again."
    },
    {
      "title": "Separation of Concerns",
      "fileName": "user.module",
      "fileType": ".ts",
      "code": "import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { UserComponent } from './user.component';\n\n@NgModule({\n  declarations: [UserComponent],\n  imports: [CommonModule],\n  exports: [UserComponent]\n})\nexport class UserModule {}",
      "description":"In the end, your structure will probably look something like this. \n\n You can create a module for each feature of your application, such as user management, product management, etc. Each module can contain its own components, directives, and pipes that are related to that feature. \n\n A directory specifically made for a module will likely contain that module in its root, and corresponding components, directives and pipes in their own subfolders. \n\n In the case that you have subroutes that you want to manage for that specific module, say for example a user profile that has subroutes for about, settings, etc., you can create a routing module just like we did with the app-routing module. This routing module can then be imported into the directory module, and the subroutes can be defined in the routing module. \n\n A recommended structure for such a module could look like this:\n\n```\nuser/\n  ├── user.module.ts\n  ├── user-routing.module.ts\n  ├── components/\n  │   ├── user-profile/\n  │   │   ├── user-profile.component.ts\n  │   │   ├── user-profile.component.html\n  │   │   └── user-profile.component.css\n  │   ├── user-list/\n  │   │   ├── user-list.component.ts\n  │   │   ├── user-list.component.html\n  │   │   └── user-list.component.css\n  └── services/\n      ├── user.service.ts\n      └── auth.service.ts\n```\n\n After your module is complete, you are able to import it into your app module, or your app-routing module with a specified route attached to it."
    },
    {
      "title": "Directives in Angular",
      "fileName": "mydirective.directive",
      "fileType": ".ts",
      "code": "import { Directive, ElementRef, Renderer2 } from '@angular/core';\n\n@Directive({\n  selector: '[appMyDirective]'\n})\nexport class MyDirective {\n  constructor(private el: ElementRef, private renderer: Renderer2) {\n    this.renderer.setStyle(this.el.nativeElement, 'color', 'blue');\n  }\n}",
      "description":" Angular ships prebuilt directives that allow you to create custom behavior and manipulate the DOM in a declarative way. You can also make your own, and declare them in a specified module. You'll find that Angular's directives are a bit more opinionated than Vue's, and they are usually used to create reusable components or to add behavior to existing elements. \n\n There are three types of directives in Angular: \n- **Components**: These are directives with a template. They are the most common type of directive and are used to create reusable UI components.\n- **Structural Directives**: These directives change the structure of the DOM by adding or removing elements. Examples include `ngIf`, `ngFor`, and `ngSwitch`.\n- **Attribute Directives**: These directives change the appearance or behavior of an existing element. Examples include `ngClass`, `ngStyle`, and custom attribute directives.\n\n In this example, we create a custom attribute directive called MyDirective that changes the color of an element to blue when it is applied. The directive uses the ElementRef and Renderer2 classes to access and manipulate the DOM element. \n\n Since you might need to have directives be available in multiple modules, you can create a shared module that contains all the directives you want to use in your application. This shared module can then be imported into any other module that needs access to the directives. The sharedModule is also a recommended module to contain pipes and simple reusable components that aren't specific to a module, such as custom UI components and such."
    },
    {
      "title":"Services Deep Dive",
      "fileName":"user.service",
      "fileType":".ts",
      "code":"import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  private apiUrl = 'https://api.example.com/users';\n\n  constructor(private http: HttpClient) {}\n\n  getUsers(): Observable<any> {\n    return this.http.get(this.apiUrl);\n  }\n}",
      "description":"In Angular, services are a way to share data and functionality across components. They are typically used for data access, business logic, and other reusable functionality. You generally prefer to have some logic delegated to a service instead of having it in the component, for context separation and reusability purposes. \n\n Angular uses dependency injection to provide services to components. This means that you can inject a service into a component's constructor and use it without having to create an instance of the service yourself. A good example of the delegation of certain logic to a service is the use of the HttpClient service to make HTTP requests, specially if you want to separate API calls based on the type of data you are fetching. \n\n In this example, we create a simple service called UserService that uses the HttpClient service to make HTTP requests. The UserService has a method called getUsers that returns an observable of the users from the API. This allows us to easily fetch data from the API and use it in our components without having to write the HTTP logic in each component."
    },
    {
      "title": "Pipes",
      "fileName": "my.pipe",
      "fileType": ".ts",
      "code": "import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'myPipe'\n})\nexport class MyPipe implements PipeTransform {\n  transform(value: string): string {\n    return value.toUpperCase();\n  }\n}",
      "description":"# Not the ones you smoke \n\n Angular pipes are a way to transform data in templates. They are similar to filters in Vue and React, and allow you to format data for display in the UI. Pipes take an input value and return a transformed value. \n\n Your average use case for Pipes often relates to date formatting, currencies, numbers, and other types of data. You can also create custom pipes to transform data in specific ways. \n\n In this example, we create a simple pipe called MyPipe that transforms a string to uppercase. The pipe uses the PipeTransform interface to define the transform method, which takes the input value and returns the transformed value. \n\n You can use this pipe in your templates by using the pipe operator (|) followed by the pipe name. For example: {{ 'hello' | myPipe }} will output HELLO."
    },
    {
      "title":"Guards", 
      "fileName": "auth.guard",
      "fileType": ".ts",
      "code": "import { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n  canActivate(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): boolean {\n    // Add your authentication logic here\n    return true;\n  }\n}",
      "description":"Guards are a way to control access to routes in Angular applications. They allow you to protect routes from unauthorized access and can be used to implement authentication and authorization logic. \n\n Angular provides several types of guards, including: \n- **CanActivate**: This guard is used to determine if a route can be activated. It is called before the route is activated and can return a boolean value or an observable that resolves to a boolean value.\n- **CanDeactivate**: This guard is used to determine if a route can be deactivated. It is called before the route is deactivated and can return a boolean value or an observable that resolves to a boolean value.\n- **Resolve**: This guard is used to resolve data before the route is activated. It is called before the route is activated and can return a value or an observable that resolves to a value.\n\n In this example, we create a simple AuthGuard that implements the CanActivate interface. The canActivate method contains the authentication logic and returns true if the user is authenticated, or false if the user is not authenticated."
    
    },
    {
      "title": "Forms",
      "fileName": "app.component",
      "fileType": ".ts",
      "code": "import { Component } from '@angular/core';\nimport { FormBuilder, FormGroup } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  myForm: FormGroup;\n\n  constructor(private fb: FormBuilder) {\n    this.myForm = this.fb.group({\n      name: [''],\n      email: ['']\n    });\n  }\n\n  onSubmit() {\n    console.log(this.myForm.value);\n  }\n} \n\n // app.component.html\n<form [formGroup]=\"myForm\" (ngSubmit)=\"onSubmit()\">\n  <label for=\"name\">Name:</label>\n  <input id=\"name\" formControlName=\"name\">\n\n  <label for=\"email\">Email:</label>\n  <input id=\"email\" formControlName=\"email\">\n\n  <button type=\"submit\">Submit</button>\n</form>",
      "description":"Angular provides two ways to handle forms: reactive forms and template-driven forms. Reactive forms are more powerful and flexible, while template-driven forms are easier to use for simple forms. \n\n In this example, we create a simple reactive form using the FormBuilder service. The form has two fields: name and email. We use the FormGroup class to create a group of form controls. The onSubmit method is called when the form is submitted, and it logs the form values to the console. \n\n ## FormBuilder\n\n The FormBuilder service is a helper service that makes it easier to create form groups and form controls. It provides methods for creating form groups, form arrays, and form controls. \n\n ## FormGroup\n\n The FormGroup class is used to group related form controls together. It allows you to manage the state and validation of the form group as a whole. \n\n ## FormControl\n\n The FormControl class is used to represent a single form control. It allows you to manage the state and validation of the form control.\n\n ## formGroup vs. ngModel \n\n The formGroup directive is used to bind a FormGroup instance to a form element. It allows you to manage the state and validation of the form group. The ngModel directive is used to bind a FormControl instance to a form element. It allows you to manage the state and validation of the form control. \n\n ## Template-driven forms\n\n Template-driven forms are easier to use for simple forms, but they are less powerful and flexible than reactive forms. In template-driven forms, you use the ngModel directive to bind form controls to properties in your component class. You can also use the ngForm directive to bind a FormGroup instance to a form element."
    },
    {
      "title": "Subjects and Observables",
      "fileName": "app.component",
      "fileType": ".ts",
      "code": "import { Component } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  private subject = new Subject<string>();\n\n  constructor() {\n    this.subject.subscribe(value => {\n      console.log(value);\n    });\n  }\n\n  emitValue() {\n    this.subject.next('Hello from Subject!');\n  }\n}",
      "description":"In Angular, Observables are a powerful way to handle asynchronous data streams. They are part of the RxJS library, which is included with Angular. Observables allow you to work with asynchronous data in a more declarative way, making it easier to manage complex data flows. \n\n Observables are similar to Promises, but they can emit multiple values over time, while Promises can only emit a single value. Observables also provide a rich set of operators for transforming and manipulating data streams. \n\n In this example, we create a simple Subject that emits a string value. The Subject is a type of Observable that allows you to manually emit values. We subscribe to the Subject and log the emitted value to the console. The emitValue method is called when the button is clicked, and it emits a value using the next method.\n\n ## The next() method\n\n The next method is used to emit a value from the Subject. It takes a single argument, which is the value to be emitted. In this example, we emit the string 'Hello from Subject!' when the button is clicked. \n\n ## The subscribe() method\n\n The subscribe method is used to listen for emitted values from the Observable. It takes a callback function as an argument, which is called whenever a new value is emitted. In this example, we log the emitted value to the console. \n\n ## Use cases\n\n Subjects are often used for event handling, data sharing between components, and managing state in Angular applications. They are a powerful tool for managing asynchronous data flows and can be used in conjunction with other RxJS operators to create complex data streams. In particular, subjects are often used in conjunction with services to share data between components. For example, you can create a service that uses a Subject to emit data, and then inject that service into multiple components to share the data between them. ",
      "output":"Hello from Subject!"
    },
    {
      "title":"Reactivity",
      "fileName":"app.component",
      "fileType":".ts",
      "code":"import { Component } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  private behaviorSubject = new BehaviorSubject<string>('Initial Value');\n\n  constructor() {\n    this.behaviorSubject.subscribe(value => {\n      console.log(value);\n    });\n  }\n\n  emitValue() {\n    this.behaviorSubject.next('Hello from BehaviorSubject!');\n  }\n}",
      "description":"BehaviorSubject is a type of Subject that requires an initial value and emits its current value to new subscribers. It is useful for representing the current state of a value and allows you to easily access the latest emitted value. \n\n In this example, we create a BehaviorSubject with an initial value of 'Initial Value'. When the component is created, we subscribe to the BehaviorSubject and log the emitted value to the console. The emitValue method is called when the button is clicked, and it emits a new value using the next method. \n\n ## Use cases\n\n BehaviorSubjects are often used for managing state in Angular applications, as they allow you to easily access the current state of a value and emit new values when the state changes. They are particularly useful for sharing state between components and services."
    },
    {
      "title": "CDRef Change Detection",
      "fileName": "app.component",
      "fileType": ".ts",
      "code": "import { Component, ChangeDetectorRef } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'Angular Starter';\n\n  constructor(private cdr: ChangeDetectorRef) {}\n\n  updateTitle() {\n    this.title = 'Updated Title';\n    this.cdr.detectChanges();\n  }\n}",
      "description":"Change detection is a mechanism in Angular that allows the framework to detect changes in the application state and update the view accordingly. Angular uses a change detection strategy to determine when to check for changes and update the view. \n\n By default, Angular uses the `Default` change detection strategy, which checks for changes on every event cycle. However, you can also use the `OnPush` change detection strategy to optimize performance by only checking for changes when the input properties of a component change or when an event occurs. \n\n In this example, we use the ChangeDetectorRef service to manually trigger change detection. The updateTitle method updates the title property and calls the detectChanges method to manually trigger change detection. This is useful in cases where you need to update the view but Angular's default change detection does not detect the changes automatically."
    },
    {
      "title": "OnPush Change Detection",
      "fileName": "app.component",
      "fileType": ".ts",
      "code": "import { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class AppComponent {\n  title = 'Angular Starter';\n\n  updateTitle() {\n    this.title = 'Updated Title';\n  }\n}",
      "description":"The OnPush change detection strategy is an optimization technique that allows you to control when Angular checks for changes in a component. By default, Angular uses the Default change detection strategy, which checks for changes on every event cycle. However, this can lead to performance issues in large applications with many components. \n\n The OnPush change detection strategy tells Angular to only check for changes when the input properties of a component change or when an event occurs. This can significantly improve performance by reducing the number of change detection cycles. \n\n In this example, we use the OnPush change detection strategy in the AppComponent. The updateTitle method updates the title property, but since we are using OnPush, we need to ensure that the input properties change or trigger an event for Angular to detect the changes."
    },
    {
      "title":"Zone Change Detection",
      "fileName":"app.component",
      "fileType":".ts",
      "code":"import { Component } from '@angular/core';\nimport { NgZone } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'Angular Starter';\n\n  constructor(private ngZone: NgZone) {}\n\n  runOutsideAngular() {\n    this.ngZone.runOutsideAngular(() => {\n      // Code that doesn't need change detection\n    });\n  }\n}",
      "description":"Zone.js is a library that Angular uses to manage change detection. It creates a zone around asynchronous operations, allowing Angular to detect changes and update the view automatically. \n\n However, there are cases where you may want to run code outside of Angular's zone to avoid triggering change detection unnecessarily. This can improve performance in certain scenarios, such as when you are performing heavy computations or working with third-party libraries that don't need change detection. \n\n In this example, we use the NgZone service to run code outside of Angular's zone. The runOutsideAngular method allows you to execute code without triggering change detection. This is useful for optimizing performance in certain scenarios. \n\n Other uses for the NgZone service include: \n- Running code that doesn't need change detection, such as third-party libraries or heavy computations.\n- Running code that needs to be executed outside of Angular's zone, such as when using setTimeout or setInterval.\n- Running code that needs to be executed"
    },
    {
      "title": "Lifecycle Hooks",
      "fileName": "app.component",
      "fileType": ".ts",
      "code": "import { Component, OnInit, OnDestroy } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit, OnDestroy {\n  title = 'Angular Starter';\n\n  ngOnInit() {\n    console.log('Component initialized');\n  }\n\n  ngOnDestroy() {\n    console.log('Component destroyed');\n  }\n}",
      "description":"Lifecycle hooks are methods that allow you to tap into the lifecycle of a component or directive. They provide a way to perform actions at specific points in the lifecycle, such as when the component is created, updated, or destroyed. \n\n Angular provides several lifecycle hooks that you can implement in your components and directives. Some of the most commonly used lifecycle hooks include: \n- `ngOnInit`: Called once the component is initialized. This is a good place to perform initialization logic, such as fetching data from a service.\n- `ngOnChanges`: Called when input properties change. This is useful for responding to changes in input properties.\n- `ngOnDestroy`: Called just before the component is destroyed. This is a good place to perform cleanup logic, such as unsubscribing from observables or detaching event listeners.\n\n In this example, we implement the OnInit and OnDestroy lifecycle hooks in the AppComponent. The ngOnInit method logs a message when the component is initialized, and the ngOnDestroy method logs a message when the component is destroyed."
    },
    {
      "title":"Subscription Management",
      "fileName":"app.component",
      "fileType":".ts",
      "code":"import { Component, OnInit, OnDestroy } from '@angular/core';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit, OnDestroy {\n  title = 'Angular Starter';\n  private subscription: Subscription;\n\n  ngOnInit() {\n    this.subscription = this.someObservable.subscribe(value => {\n      console.log(value);\n    });\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}",
      "description":"In Angular, when you subscribe to an observable, it creates a subscription that allows you to receive emitted values. However, it is important to manage subscriptions properly to avoid memory leaks and ensure that resources are released when the component is destroyed. \n\n In this example, we create a subscription in the ngOnInit method and unsubscribe from it in the ngOnDestroy method. This ensures that the subscription is properly cleaned up when the component is destroyed. \n\n ## Use cases\n\n Subscription management is important in Angular applications, especially when dealing with observables that emit values over time. It is important to unsubscribe from observables when they are no longer needed to avoid memory leaks and ensure that resources are released. You can also use operators like takeUntil or takeWhile to automatically unsubscribe from observables based on certain conditions."
    },
    {
      "title": "More About RxJS",
      "fileName": "app.component",
      "fileType": ".ts",
      "code": "import { Component } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  data$: Observable<number[]>;\n\n  constructor() {\n    this.data$ = of([1, 2, 3, 4, 5]).pipe(\n      filter(value => value > 2),\n      map(value => value * 2)\n    );\n  }\n}",
      "description":"RxJS is a powerful library for reactive programming using observables. It provides a rich set of operators for transforming and manipulating data streams. \n\n In this example, we create an observable using the of operator, which emits an array of numbers. We then use the pipe method to chain together multiple operators, such as filter and map, to transform the emitted values. The filter operator filters out values that do not meet a certain condition, while the map operator transforms the emitted values. \n\n ## RxJS and Subscription Management\n\n RxJS is often used in conjunction with subscription management to handle asynchronous data streams. You can use operators like takeUntil or takeWhile to automatically unsubscribe from observables based on certain conditions. This helps to avoid memory leaks and ensures that resources are released when the component is destroyed. \n\n ## Operators\n\n RxJS provides a rich set of operators for transforming and manipulating data streams. Some commonly used operators include: \n- `map`: Transforms the emitted values by applying a function to each value.\n- `filter`: Filters the emitted values based on a condition.\n- `mergeMap`: Merges multiple observables into a single observable.\n- `switchMap`: Switches to a new observable and cancels the previous one.\n- `combineLatest`: Combines multiple observables and emits the latest values from each observable.\n\n ## Use cases\n\n RxJS is commonly used in Angular applications for handling asynchronous data streams, such as HTTP requests, user input events, and other asynchronous operations. It provides a powerful way to manage complex data flows and allows you to easily compose and transform data streams."
    },
    {
      "title":"RxJS and State Management",
      "fileName":"app.component",
      "fileType":".ts",
      "code":"import { Component } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  private state = new BehaviorSubject<any>({});\n\n  constructor() {\n    this.state.subscribe(value => {\n      console.log(value);\n    });\n  }\n\n  updateState(newState: any) {\n    this.state.next(newState);\n  }\n}",
      "description":"RxJS can be used for state management in Angular applications. By using observables and subjects, you can create a reactive state management system that allows you to easily manage and update the application state. \n\n In this example, we create a BehaviorSubject to represent the application state. The BehaviorSubject emits the current state to subscribers, allowing you to easily access and update the state. The updateState method is called to update the state with a new value."
    },
    {
      "title":"State Management Libraries",
      "fileName":"app.component",
      "fileType":".ts",
      "code":"import { Component } from '@angular/core';\nimport { Store } from '@ngrx/store';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  constructor(private store: Store<any>) {}\n\n  dispatchAction() {\n    this.store.dispatch({ type: 'ACTION_TYPE' });\n  }\n}",
      "description":"There are several state management libraries available for Angular, including NgRx, Akita, and NGXS. These libraries provide a way to manage application state in a more structured and scalable way. \n\n In this example, we use the NgRx library to manage application state. The Store service is used to dispatch actions and manage the application state. The dispatchAction method is called to dispatch an action to the store."
    },
    {
      "title": "Built-in Testing Utilities",
      "fileName": "app.component.spec",
      "fileType": ".ts",
      "code": "import { TestBed } from '@angular/core/testing';\nimport { AppComponent } from './app.component';\n\ndescribe('AppComponent', () => {\n  let component: AppComponent;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [AppComponent]\n    });\n    component = TestBed.createComponent(AppComponent).componentInstance;\n  });\n\n  it('should create the app', () => {\n    expect(component).toBeTruthy();\n  });\n});",
      "description":"Angular provides built-in testing utilities to help you write unit tests for your components, services, and other parts of your application. Usually this is provided by Karma and Jasmine, but you can also use Jest if you prefer. \n\n The testing utilities include TestBed, ComponentFixture, and other utilities that make it easier to test Angular applications. \n\n \n## TestBed\n\n  The TestBed utility is used to configure and create an Angular testing module, allowing you to test components in isolation. \n\n In this example, we use the TestBed utility to create a test for the AppComponent. The beforeEach function is used to set up the testing module and create an instance of the component. The it function is used to define a test case, which checks that the component is created successfully. \n\n This specific topic is further expanded in the corresponding language section."
    }
  ]
}
