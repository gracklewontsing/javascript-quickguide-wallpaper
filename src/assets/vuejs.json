{
  "language": "Vue.js",
  "documentationUrl": "https://vuejs.org/guide/introduction.html",
  "snippets": [
    {
      "title": "Vue.js Starter",
      "fileName": "HelloWorld",
      "fileType": ".vue",
      "code": "<template>\n  <h1>{{ message }}</h1>\n</template>\n\n<script>\nexport default {\n  data() {\n    return { message: 'Hello, Vue!' };\n  },\n};\n</script>",
      "description": "Vue is known for its simplicity, lenient learning curve and ease of integration, making it an excellent choice for both small and large applications. Its declarative rendering and reactive data-binding system provide a smooth developer experience, allowing you to focus on writing clean and maintainable code.   \n\nVue's Single File Components (SFCs) offer a structured and scalable approach to organizing code, while its flexibility allows for easy integration with other libraries and existing projects.  \n\n **Ok but why Vue?** \n\n I dunno. I like it. It all depends on what you're looking for. If we were to tie the three major frameworks to your average RPG class archetypes, Vue would probably fit as the Mage: flexible, easy to learn, powerful when mastered, all while focusing on the development experience. Don't ask how I came up with this metaphor. \n\n# Vue Component Basics\nThis is a basic Vue Single File Component (SFC), which typically includes three parts:\n\n- `<template>`: defines the HTML structure.\n- `<script>`: contains the component logic and reactive state.\n- `<style>`: optional, for component-specific CSS (not shown here).\n\nThe `data()` function returns an object containing reactive properties. Here, `message` is bound to the template using double curly braces (`{{ message }}`). Any changes to `message` will automatically update the DOM ‚Äî a core feature of Vue's reactivity system.\n\n \n\nYou can enhance SFCs further by:\n- Adding `lang=\"ts\"` for TypeScript support.\n- Using the Composition API with `<script setup>`.\n- Writing JSX inside `<script lang=\"jsx\">`.\n- Using preprocessor languages in `<style>` with `lang=\"scss\"`, `sass`, etc.\n\nThese features require proper tooling support (like Vite or Vue CLI) and the necessary dependencies installed. Like other node frameworks, Vue can be further enhanced with npm packages.  \n\n This webapp was made with Vue.js! üëç",
      "output": "Hello, Vue!"
    },
    {
      "title": "The Composition API",
      "fileName": "CompositionExample",
      "fileType": ".vue",
      "code": "<template>\n  <h1>{{ count }}</h1>\n  <button @click=\"increment\">Increment</button>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\n\nconst count = ref(0);\nconst increment = () => {\n  count.value++;\n};\n</script>",
      "description": "# Vue Composition API (`<script setup>`)\n The Composition API is the most widely accepted script format for vue3+. The `<script setup>` is a concise way to use the Composition API in Vue single-file components, reducing boilerplate and making your code more readable. However, you may also use a setup() function inside your script to use the features of the Composition API.\n\n### The Difference Between `setup()` and `<script setup>`:\n\n- **`setup()` function**: Inside the setup function, you would declare all your reactive data and methods inside a return. The `setup()` function returns values that can be used in the template (like `count` and `increment` in the previous example). It is called at the beginning of the component's lifecycle before the template is evaluated.\n\n- **`<script setup>`**: Adding setup to the script is syntactic sugar, and works as shorthand for implicitly using the Composition API in your component. With this, you no longer need to explicitly define the `setup()` function or return values, because all reactive properties and functions declared inside `<script setup>` are automatically available in the template. It is preferrable for more concise and less boilerplated code.\n\nIn this example, `count` is a reactive reference created by calling `ref(0)`. The `increment` function modifies `count.value`, and the template automatically reacts to any changes in `count`.\n\n Users can still use the Options API if they use the corresponding syntax. \n\n This webapp uses the Composition API!",
      "output": "0 (initially) ‚Üí increments by 1 each time the button is clicked"
    },
    {
      "title": "Vue Component with TypeScript",
      "fileName": "TsComponentExample",
      "fileType": ".vue",
      "code": "<template>\n  <h1>{{ message }}</h1>\n  <button @click=\"increment\">Increment</button>\n  <p>Count: {{ count }}</p>\n</template>\n\n<script lang=\"ts\">\nimport { ref } from 'vue';\n\nexport default {\n  name: 'TsComponentExample',\n  setup() {\n    // Defining a string message and a count state with types\n    const message: string = 'Hello, TypeScript with Vue!';\n    const count = ref<number>(0);\n\n    // Increment function to update the count\n    const increment = (): void => {\n      count.value++;\n    };\n\n    // Returning variables to the template\n    return { message, count, increment };\n  }\n};\n</script>",
      "description": "# Vue with TypeScript (`<script lang='ts'>`)\n Vue supports TypeScript out of the box, allowing you to leverage static type checking and autocompletion.\n\n- The `message` is typed as `string`, and `count` is a `ref` with a type of `number`.\n- The `increment` function is typed as `void`, meaning it doesn't return anything.\n- Vue's `setup()` function is used to declare reactive properties (`count`) and methods (`increment`) that are returned to the template.\n\nThe Composition API can also be paired with TypeScript, allowing for type safety and better tooling support. You do have to make sure to have the correct TypeScript and Vue types dependencies in your environment. If you use Vite, you can simply choose Typescript in your configuration. \n\nThis webapp also uses TypeScript!"
    },
    {
      "title": "Recommended File Structure",
      "fileName": "FileStructure",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <h1>Recommended File Structure</h1>\n    <p>src/\n      ‚îú‚îÄ‚îÄ assets/\n      ‚îú‚îÄ‚îÄ components/\n      ‚îú‚îÄ‚îÄ views/\n      ‚îú‚îÄ‚îÄ router/\n      ‚îú‚îÄ‚îÄ store/\n      ‚îú‚îÄ‚îÄ App.vue\n      ‚îî‚îÄ‚îÄ main.js\n  </div>\n</template>\n\n<script setup>\n\n</script>",
      "description": "# Recommended File Structure\n Your average Vue project often has the following recommended structure (not including specific environment/webpack/styles/etc configs):\n\n```\nsrc/\n  ‚îú‚îÄ‚îÄ assets/          # Static assets like images, fonts, etc.\n  ‚îú‚îÄ‚îÄ components/      # Reusable Vue components\n  ‚îú‚îÄ‚îÄ views/           # Views or pages of the application\n  ‚îú‚îÄ‚îÄ router/          # Vue Router configuration\n  ‚îú‚îÄ‚îÄ store/           # Vuex store (if using Vuex for state management)\n  ‚îú‚îÄ‚îÄ App.vue          # Root component\n  ‚îî‚îÄ‚îÄ main.js          # Entry point of the application\n```\n\n### Explanation:\n- **assets/**: Contains static files such as images, fonts, and other resources that are not components.\n- **components/**: Contains your reusable Vue components that can be used across different views.\n- **views/**: Contains the main views or pages of the application (the ones you'd usually point to with routes e.g: Contact.vue: /contact). You can have as many components as you need in a given view.\n- **router/**: Contains the routing configuration for the application using Vue Router. It is not necessary (this project doesn't use routes), but if you do need it, it is often recommended that you configure them here.\n- **store/**: Contains the Vuex store configuration if you're using Vuex for state management.\n- **App.vue**: The root component of your application. You usually call the router-view component (if you use router) or views in this. Since I didn't use routes, you are essentially watching this file calling a few components instead. \n- **main.js**: The entry point of your application where you initialize Vue and mount the root component. This is also where you import npm packages if you use them globally. \n\n New vue projects will often create a boilerplate that follows or nudges you toward this kind of structure, but you can use a different structure if you want. I ain't your boss."
    },
    {
      "title": "Assets vs Public Folder",
      "fileName": "assets",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <h1>Assets vs Public Folder</h1>\n    <p>src/assets/ - For images, fonts, and other static files used in components.</p>\n    <p>public/ - For static files that are served directly without processing.</p>\n  </div>\n</template>\n\n<script setup>\n\n</script>",
      "description": "# Assets vs Public Folder\nThe `assets` and `public` folders behave differently when building apps, so it usually isn't just a preference thing.\n\n### `src/assets/`\n- **Purpose**: This folder is used for images, fonts, and other static files that are imported into your components.\n- **Processing**: Files in this folder are processed by Webpack (or the build tool you are using). This means they can be optimized, minified, or hashed during the build process.\n- **Usage**: You can import assets from this folder directly in your components. For example:\n```javascript\nimport logo from '@/assets/logo.png';\n```\n- **Example**: If you have an image that you want to use in a component, you would place it in `src/assets/` and import it as shown above.\n\n### `public/`\n- **Purpose**: This folder is used for static files that should be served directly without any processing.\n- **No Processing**: Files in this folder are not processed by Webpack. They are copied directly to the root of the output directory during the build process.\n- **Usage**: You can reference files in this folder using absolute paths. For example:\n```html\n<img src=\"/logo.png\" alt=\"Logo\">\n```\n- **Example**: If you have a favicon or a static HTML file that should not be processed, you would place it in the `public/` folder.\n\n"
    },
    {
      "title": "The Main.js File",
      "fileName": "main",
      "fileType": ".js",
      "code": "import { createApp } from 'vue';\nimport App from './App.vue';\nimport router from './router';\nimport store from './store';\n\nconst app = createApp(App);\napp.use(router);\napp.use(store);\napp.mount('#app');",
      "description": "# The main.js File\nThe `main.js` file is the entry point of a Vue.js application. It is where you create and configure your Vue instance, set up routing, state management, and mount the application to the DOM. If you use npm packages, this is usually where you import and use them if you want access to them all around your project (e.g: if you install axios, you would import axios and have app.use(axios) or so).\n\n Keep in mind that a lot of packages require different import methods when installed to vue. You may refer to their corresponding documentations if that is the case. \n\n### Explanation:\n- **Importing Vue**: The `createApp` function from the Vue library is imported to create a new Vue application instance.\n- **Root Component**: The root component (`App.vue`) is imported, which serves as the main component for the application.\n- **Router**: If you're using Vue Router for navigation, it is imported and used with the app instance.\n- **Store**: If you're using Vuex for state management, it is also imported and used with the app instance.\n- **Mounting**: Finally, the app instance is mounted to a DOM element with the ID `app`, which is typically defined in your `index.html` file.\n\nThis structure allows you to easily manage your application's configuration and dependencies in one place. Incidentally, if you choose to use typescript, you can rename this file to `main.ts` and use the same code with TypeScript syntax. "
    },
    {
      "title": "Routing in Vue",
      "fileName": "router",
      "fileType": ".js",
      "code": "import { createRouter, createWebHistory } from 'vue-router';\nimport Home from '../views/Home.vue';\nimport About from '../views/About.vue';\n\nconst routes = [\n  {\n    path: '/',\n    name: 'Home',\n    component: Home,\n  },\n  {\n    path: '/about',\n    name: 'About',\n    component: About,\n  },\n];\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes,\n});\n\nexport default router;",
      "description": "# Routing in Vue\nVue Router is the official router for Vue.js, enabling navigation between different views or components in a Vue application. It allows you to create single-page applications (SPAs) with dynamic routing.\n\n### Explanation:\n- **Importing Vue Router**: The `createRouter` and `createWebHistory` functions are imported from the `vue-router` package.\n- **Defining Routes**: An array of route objects is defined, where each object specifies a path, a name, and the component to render when that path is accessed.\n- **Creating Router Instance**: The `createRouter` function is called with the history mode (using `createWebHistory`) and the defined routes. History mode is the one you would use for HTML5, where you can manage routes in the url. If you need different modes, you change this function to a different one that suits your needs.\n- **Exporting Router**: The router instance is exported for use in the main application file (`main.js`), which can be seen in the previous example.\n\nThis specific setup allows you to define multiple routes and their corresponding components, enabling smooth navigation within your Vue application. If you use history mode, it is recommended to set up a fallback route to handle 404 errors and redirect them to your index.html file. "
    },
    {
      "title": "Vue Directives",
      "fileName": "DirectivesExample",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <p v-if=\"isVisible\">This text is conditionally rendered based on the value of isVisible.</p>\n    <button @click=\"toggleVisibility\">Toggle Visibility</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      isVisible: true,\n    };\n  },\n  methods: {\n    toggleVisibility() {\n      this.isVisible = !this.isVisible;\n    },\n  },\n};\n</script>",
      "description": "# Vue Directives\nDirectives are special tokens in the markup that tell Vue to do something to a DOM element or component. They provide the ability to bind dynamic behaviors to the DOM. Common Vue directives include:\n\n- `v-if`: Conditionally renders an element.\n- `v-for`: Loops over data and renders elements.\n- `v-bind`: Dynamically binds an attribute to an expression.\n- `v-model`: Creates two-way data binding on form elements.\n\nIn this example:\n- `v-if=\"isVisible\"`: The `<p>` element is only rendered when `isVisible` is `true`.\n- `@click=\"toggleVisibility\"`: The button's click event is bound to the `toggleVisibility` method, which toggles the `isVisible` state.\n\nVue's directive system provides a declarative approach to DOM manipulation, making it easier to manage UI state in a clean and maintainable way.\n",
      "output": "The paragraph will toggle visibility when the button is clicked. Initially, the paragraph is visible."
    },
    {
      "title": "Advanced Vue Directives",
      "fileName": "ComplexDirectivesExample",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <h1 v-bind:style=\"styleObject\">This text is styled dynamically using v-bind:style</h1>\n    <p v-show=\"isVisible\">This text will appear/disappear based on isVisible.</p>\n    <button v-on:click=\"toggleVisibility\">Toggle Visibility</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      isVisible: true,\n      styleObject: {\n        color: 'red',\n        fontSize: '20px',\n      },\n    };\n  },\n  methods: {\n    toggleVisibility() {\n      this.isVisible = !this.isVisible;\n    },\n  },\n};\n</script>",
      "description": "# Complex Vue Directives\nThis example showcases some advanced Vue directives, such as `v-bind`, `v-show`, and event handling. These directives enable a more declarative and powerful way to manipulate DOM elements based on component state.\n\n- `v-bind:style`: Dynamically binds a JavaScript object to a style attribute. In this case, `styleObject` defines the CSS properties for the element.\n- `v-show`: Toggles the visibility of an element, but unlike `v-if`, it does not remove the element from the DOM. It just sets `display: none` when `isVisible` is `false`.\n- `v-on:click`: Listens for the click event on the button and triggers the `toggleVisibility` method, toggling the visibility of the paragraph.\n\n## Other Directives:\n- `v-for`: Loops through an array or object and renders a list of elements.\n- `v-if` and `v-else`: Conditionally renders elements based on an expression.\n- `v-bind`: Dynamically binds an attribute to an expression, not limited to styles, such as `href` or `class`.\n- `v-model`: Creates two-way data binding for form elements, syncing data between input and component state.\n- `v-pre`: Skips compilation for this element and all its children. Useful for displaying raw HTML templates.\n- `v-cloak`: Keeps an element and its children from being displayed until Vue's compilation is finished.\n- `v-on`: Binds event listeners to elements, including custom events.\n\n",
      "output": "The heading will have dynamic styling, the paragraph will toggle visibility when the button is clicked, and initial visibility is true."
    },
    {
      "title": "The Lifecycle",
      "fileName": "LifecycleExample",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <h1>{{ message }}</h1>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      message: 'Life goes on, I need all my babies!'\n    };\n  },\n  created() {\n    console.log('created: Component is created!');\n  },\n  mounted() {\n    console.log('mounted: Component has been mounted to the DOM!');\n  },\n  updated() {\n    console.log('updated: Component data has been updated!');\n  },\n  destroyed() {\n    console.log('destroyed: Component is about to be destroyed!');\n  }\n};\n</script>",
      "description": "# Vue Lifecycle Hooks\nVue components go through a series of stages during their existence, and the **lifecycle hooks** are methods that allow you to run code at each of these stages. These hooks provide insight and control over the component‚Äôs lifecycle, enabling actions such as initializing data, performing AJAX requests, or cleaning up before a component is destroyed.\n\nIn this example, we demonstrate the most common lifecycle hooks: `created`, `mounted`, `updated`, and `destroyed`.\n\n- `created()`: This hook is called right after the component is created, but before it is mounted to the DOM. You can use this hook to set up initial data, perform data fetching, or perform any initialization tasks.\n\n- `mounted()`: This hook is called once the component has been inserted into the DOM. It's a good place to run code that requires the component to be displayed on the page, such as making API calls or accessing DOM elements.\n\n- `updated()`: This hook is triggered whenever reactive data in the component changes. It‚Äôs useful when you need to perform tasks after the DOM has been updated in response to data changes.\n\n- `destroyed()`: This hook is called just before the component is destroyed and removed from the DOM. It's useful for cleanup, like invalidating timers, canceling AJAX requests, or removing event listeners.\n\nLifecycle hooks provide flexibility in managing a component‚Äôs behavior, giving you control at various stages of its lifecycle.\n\n### Other Lifecycle Hooks (briefly):\n- `beforeCreate()`: Called before the component instance is created. Not commonly used directly, but can be used for setup tasks before the component‚Äôs reactive properties are available.\n- `beforeMount()`: Called right before the component is mounted to the DOM. You can use it to perform actions just before the DOM is rendered.\n- `beforeUpdate()`: Called when data changes but before the DOM is re-rendered. It‚Äôs useful if you need to perform an action before the UI update.\n- `activated()`: Called when a kept-alive component is activated (used in scenarios with `<keep-alive>`).\n- `deactivated()`: Called when a kept-alive component is deactivated.\n\nVue‚Äôs lifecycle hooks allow you to finely control your component‚Äôs behavior, ensuring you can respond to changes, manage resources, and interact with external systems effectively.",
      "output": "The console will log messages during each lifecycle stage: created, mounted, updated, and destroyed."
    },
    {
      "title": "Methods & Computed",
      "fileName": "MethodsComputedExample",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <h1>{{ message }}</h1>\n    <p>Double of count: {{ doubleCount }}</p>\n    <button @click=\"increment\">Increment</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed } from 'vue';\n\nconst count = ref(0);\nconst message = ref('Hello, Vue!');\n\nconst doubleCount = computed(() => count.value * 2);\n\nconst increment = () => {\n  count.value++;\n};\n</script>",
      "description": "# Methods & Computed, and their differences between APIs \nIn Vue, `methods` and `computed` are two key ways to handle dynamic behavior. While they can sometimes seem similar, they have different use cases and are optimally used in different scenarios.\n\n A key difference between the Composition API and the Options API is how each organize these features respectively. \n\nIn the **Options API**, you define `methods()` and `computed()` as part of the component's object. Here's a basic example:\n\n```vue\n<template>\n  <div>\n    <h1>{{ message }}</h1>\n    <p>Double of count: {{ doubleCount }}</p>\n    <button @click=\"increment\">Increment</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      message: 'Hello, Vue!'\n    };\n  },\n  methods: {\n    increment() {\n      this.count++;\n    }\n  },\n  computed: {\n    doubleCount() {\n      return this.count * 2;\n    }\n  }\n};\n</script>\n```\n\n### Composition API:\n In the **Composition API**, methods are generally written inside the `setup()` function, using reactive references (`ref()`) and the `computed()` function for computed properties. \n\n- `computed()`: Just like in the Options API, `computed()` defines a reactive value that is automatically updated when the dependencies change. However, it‚Äôs now imported directly from the Vue library and used inside the `setup()` function.\n\n- `methods()`: In the Composition API, methods are typically written as plain functions, directly inside `setup()` without needing the `methods` object. These methods still have access to component state (via `ref()` and `reactive()`), and you can interact with them directly in templates.\n\n The composition API is usually preferred, because it encourages a different style where logic can be grouped based on its purpose rather than by its type.\n\n### Computed vs. Methods:\n- **`methods`** are functions that trigger side effects, and can be used in the template with `@click` or any other events. They are non-reactive and can change the state directly.\n- **`computed`** properties are cached values based on the reactive dependencies and will only recompute when those dependencies change.\n\n"
    },
    {
      "title": "Basic and Complex Reactivity",
      "fileName": "ReactivityExample",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <h1>Basic Reactivity</h1>\n    <p>{{ count }}</p>\n    <button @click=\"increment\">Increment Count</button>\n    <hr>\n    <h1>Complex Reactivity</h1>\n    <p>Full Name: {{ fullName }}</p>\n    <button @click=\"updateName\">Update Name</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref, reactive, computed } from 'vue';\n\n// Basic Reactivity\nconst count = ref(0);\nconst increment = () => { count.value++; };\n\n// Complex Reactivity\nconst state = reactive({ firstName: 'John', lastName: 'Doe' });\nconst fullName = computed(() => `${state.firstName} ${state.lastName}`);\nconst updateName = () => {\n  state.firstName = 'Jane';\n  state.lastName = 'Smith';\n};\n</script>",
      "description": "# Reactivity in Vue (Basic & Complex)\nVue provides a powerful reactivity system that makes it easy to manage and update component state in response to changes. Reactivity is a core feature of Vue that ensures your UI stays in sync with the underlying state. It can be broken down into basic reactivity (using `ref()`) and more complex reactivity (using `reactive()` and `computed()`).\n\n### Basic Reactivity (with `ref()`):\nThe `ref()` function is used to create a reactive reference to a simple value (like a number, string, or boolean). When the value changes, the DOM will automatically update to reflect those changes.\n\nIn this example, we create a simple counter:\n- The `count` variable is a reactive reference created with `ref()`. It‚Äôs initially set to `0`.\n- The `increment` method increases the value of `count` by 1 each time the button is clicked.\n- Vue automatically re-renders the component‚Äôs template whenever `count` changes, thanks to its reactivity system.\n\n### Complex Reactivity (with `reactive()` and `computed()`):\nFor more complex objects or arrays, Vue provides `reactive()` to make an entire object reactive. Unlike `ref()`, which only tracks a single value, `reactive()` tracks the entire object or array, making all of its properties reactive.\n\nIn this example, we create a reactive object called `state` to manage a user‚Äôs full name:\n- `state` is an object with `firstName` and `lastName` as properties, created using `reactive()`. Changing any property in this object will automatically trigger reactivity.\n- `fullName` is a computed property that concatenates `firstName` and `lastName`. It‚Äôs automatically updated whenever either of the properties in `state` changes.\n- The `updateName` function modifies `firstName` and `lastName`, triggering a reactive update in `fullName`.\n\n### Key Differences Between Basic and Complex Reactivity:\n- **Basic Reactivity**: Used for simple values like numbers or strings. `ref()` is ideal for handling primitive values.\n- **Complex Reactivity**: Used for objects or arrays. `reactive()` allows you to make an entire object reactive, and `computed()` is used to create derived properties based on reactive state.\n\nVue‚Äôs reactivity system ensures that all changes to the state are reflected automatically in the UI, making state management easy and efficient. By combining `ref()`, `reactive()`, and `computed()`, you can build dynamic and responsive components that react to changes in the state."
    },
    {
      "title": "List Rendering",
      "fileName": "ItemList",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <h2>Shopping List</h2>\n    <ul>\n      <li v-for=\"(item, index) in shoppingList\" :key=\"index\">\n        {{ index + 1 }}. {{ item }}\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst shoppingList = ref([\n  'Milk',\n  'Bread',\n  'Eggs',\n  'Cheese'\n])\n</script>",
      "description": "# Vue.js List Rendering\nThe `v-for` directive is key to iterating over arrays or objects, generating DOM elements for each item.\n\n- `v-for`: Loops through an array or object and renders a list of elements. In this example, it loops through the `shoppingList` array and creates a `<li>` element for each item.\n- `(item, index) in shoppingList`: The syntax `(item, index)` is used to capture both the current item and its index in the array. The `item` represents the element (e.g., 'Milk'), and the `index` gives the current position in the array (e.g., 0 for 'Milk'). If the index is not needed, you can omit it.\n- `:key`: The `:key` attribute is crucial for Vue‚Äôs internal optimization of list rendering. It helps Vue track each element uniquely when updating or reordering the list, ensuring smooth performance.\n\n## Important Vue Directives in List Rendering\n- `v-for`: Iterates over an array or object. It is typically used for rendering lists dynamically. The syntax `(item, index) in array` is used to get the current item and its position in the array. `v-for` is not limited to rendering lists of simple values. You can also use v-for to render lists of nested elements, even custom components. \n- `v-bind:key`: The `key` attribute should always be provided when rendering lists in Vue. It helps Vue identify which items have changed, been added, or removed, which boosts performance and prevents rendering bugs. You can often use the index of an item as the key, but if you prefer you can also use other properties of an item, such as a 'item.id' unique key, or something similar. \n\n## Other Vue Directives\n- `v-if` and `v-else`: Conditionally renders elements. You can use them with `v-for` to show or hide elements based on certain conditions.\n- `v-bind`: Binds an attribute to an expression. This can be used dynamically to modify things like class names, styles, or data attributes.\n- `v-on`: Attaches event listeners to elements, such as `v-on:click` or `v-on:mouseover`, allowing for interactivity in the UI.\n- `v-model`: Creates two-way data binding for form inputs, syncing the input value with your component‚Äôs state.\n\nIn this example, `v-for` helps you display each item in the `shoppingList` dynamically. It also showcases how to use `index` to display the position of each item in the list, making the rendering process flexible and optimized for performance."
    },
    {
      "title": "Props in Vue with defineProps",
      "fileName": "PropsDefineExample",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <h1>{{ greeting }} from {{ name }}</h1>\n  </div>\n</template>\n\n<script setup>\n// Using `defineProps` to define props in the Composition API\nconst props = defineProps({\n  greeting: {\n    type: String,\n    required: true,\n  },\n  name: {\n    type: String,\n    required: true,\n  },\n});\n</script>",
      "description": "# Props in Vue with `defineProps`\n Props are variables that can be passed to a component by its parent. In Vue 3, the Composition API allows us to define props directly within the `<script setup>` block using `defineProps()`. \n\nIn this example, we define two props: `greeting` and `name`, which are both required strings.  One can set these props on the parent component like ```<ChildComponent :greeting=\"foo\" :name=\"bar\" />```\n\nThe `defineProps()` function is used inside the `<script setup>` block to declare the props, which are then accessible in the template without needing to reference `this` (like in Options API). Vue automatically unwraps the values from the props for use in the template, making it easier to work with reactive data.\n\n### How to Call Props in Template:\n For instance, `{{ greeting }}` and `{{ name }}` are the values of the props that will be rendered in the HTML. These props will automatically update if their values change, ensuring reactivity.\n\n### Composition API vs. Options API:\nIn the Composition API, props are defined using `defineProps()` within the `<script setup>` block. This provides a more streamlined and declarative syntax. On the other hand, in the Options API, props are defined inside the `props` option of the component, and you'd access them with `this.greeting` and `this.name` inside the component's methods or computed properties.\n\nFor example, with the Options API:\n```javascript\nexport default {\n  props: {\n    greeting: String,\n    name: String,\n  },\n  data() {\n    return {};\n  },\n  methods: {\n    someMethod() {\n      console.log(this.greeting);\n    },\n  },\n};\n```\nIn contrast, the Composition API simplifies accessing props directly in the template without the need for `this`, and encourages better code organization, especially in larger components.\n\n A few other details: \n- All props are optional by default, unless you set required to true. \n- You can set a default value for a prop by using the default property. \n- You can set a validator function to check the prop value and return a corresponding value depending on the function statement. \n-  An absent optional prop without a default that is other than Boolean will have undefined as its value. If it is boolean, it will be false. If undefined is passed by the parent and it does have a default value set, it will use the default instead. \n-  You can pass objects, arrays, and even functions as props. You can also expect these specific types if you set them in the prop definition.",
      "output": "Hello from Vue"
    },
    {
      "title": "Event Handling",
      "fileName": "EventHandling",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <!-- Method handler: Calls increaseCount method when clicked -->\n    <button @click=\"increaseCount\">Increase Count</button>\n\n    <!-- Inline handler: Passes an argument to the method -->\n    <button @click=\"increaseCount(2)\">Increase by 2</button>\n\n    <!-- Method handler for resetting count -->\n    <button @click=\"resetCount\">Reset Count</button>\n\n    <!-- Inline handler with event modifiers: prevent default and stop propagation -->\n    <button @click.prevent.stop=\"handleClick\">Click with Modifiers</button>\n\n    <p>Current Count: {{ count }}</p>\n    <p>Event Info: {{ eventInfo }}</p>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\n// Reactive state for count and event info\nconst count = ref(0)\nconst eventInfo = ref('')\n\n// Method to increase the count by a dynamic value (default is 1)\nfunction increaseCount(amount = 1) {\n  count.value += amount\n}\n\n// Method to reset the count to zero\nfunction resetCount() {\n  count.value = 0\n}\n\n// Method to handle event with access to the event object\nfunction handleClick(event) {\n  eventInfo.value = `Event triggered at ${event.timeStamp}`\n}\n</script>",
      "description": "# Vue.js Event Handling with Inline Handlers and Modifiers\n\n- **Method Handlers**: In the first button, `@click=\"increaseCount\"` calls a method when the button is clicked. This is a common pattern where you define a method in your component that reacts to the event.\n  - `increaseCount`: A method that increments the `count` by 1 each time it is invoked.\n\n- **Inline Event Handlers**: In the second button, `@click=\"increaseCount(2)\"` is an **inline event handler**, where we call the `increaseCount` method with an argument (`2`). Inline handlers can directly pass arguments to methods, which is useful when you need to call a method with dynamic data.\n  - `increaseCount(2)`: This example calls `increaseCount` and passes `2` as the argument to increase the count by 2.\n\n- **Accessing Event Arguments**: In the fourth button, the `@click` event calls `handleClick` with the native `event` object. Inline handlers can also access the native event by passing `$event` as an argument.\n  - `handleClick`: This method receives the native event object and uses `event.timeStamp` to display the time when the event was triggered.\n  - Event argument (`$event`): Inline handlers can access the native event through `$event`, providing more control over the event data (e.g., mouse position, keyboard input, etc.).\n\n- **Event Modifiers**: In the fourth button, we use **event modifiers** like `.prevent` and `.stop`. These modifiers allow for fine-grained control over event behavior.\n  - `.prevent`: This modifier prevents the default action of the event. In the case of `@click.prevent`, it prevents any default behavior that might be triggered by the click (e.g., following a link, submitting a form).\n  - `.stop`: This modifier stops the event from bubbling up the DOM. In this example, it ensures that the click event does not propagate to other elements.\n\n## Important Vue Event Handling Concepts\n- **Method Handlers**: Methods are defined in the `<script>` block and are invoked when an event occurs. The `increaseCount` method is triggered by the button click event in the template.\n- **Inline Event Handlers**: Inline handlers allow you to call methods directly from the template, often with parameters or complex expressions. They are useful for simple interactions, but it's important to avoid overly complex expressions for readability and maintainability.\n- **Accessing Event Arguments**: When using inline handlers, you can access the native DOM event by passing `$event` to your method. This is useful if you need to access details about the event, like mouse coordinates or keypresses.\n- **Event Modifiers**: Vue provides event modifiers like `.prevent` and `.stop` to control how events behave. These modifiers can be combined to prevent default actions and stop event propagation in one go, making it easier to handle user interactions in a controlled manner.\n\n### Summary of Event Modifiers\n- `.prevent`: Prevents the default behavior of the event (useful for form submissions, link navigation, etc.).\n- `.stop`: Stops the event from bubbling up the DOM (useful for preventing events from affecting parent components).\n- `.capture`: Registers the event listener in the capturing phase rather than the bubbling phase.\n- `.once`: Ensures the event handler is only triggered once.\n- `.self`: Only triggers the event handler if the event is triggered on the element itself.\n\n As a sidenote, you are not required to handle events by just using click. You can use other events such as mouseover, mouseleave, keyup, keydown, and many more. You can also use the `@` symbol to bind events in the template, which is a shorthand for `v-on:`. For example, `@click` is equivalent to `v-on:click`. "
    },
    {
      "title": "Form Input Binding",
      "fileName": "FormBinding",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <!-- Simple form input binding with v-model -->\n    <input v-model=\"inputText\" placeholder=\"Enter some text\" />\n    <p>Input Text: {{ inputText }}</p>\n\n    <!-- Value binding with .lazy modifier (syncs value on blur) -->\n    <input v-bind:value.lazy=\"inputText\" placeholder=\"Text (Lazy Sync)\" />\n    <p>Lazy Sync Text: {{ inputText }}</p>\n\n    <!-- Binding with .number modifier to force input as a number -->\n    <input v-bind:value.number=\"inputNumber\" type=\"number\" />\n    <p>Number Input: {{ inputNumber }}</p>\n\n    <!-- Using v-model with a custom component -->\n    <custom-input v-model=\"customInputValue\" />\n    <p>Custom Component Input: {{ customInputValue }}</p>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport CustomInput from './CustomInput.vue'\n\n// Reactive data for form inputs\nconst inputText = ref('')\nconst inputNumber = ref(0)\nconst customInputValue = ref('')\n</script>",
      "description": "# Form Input Binding, Modifiers, and `v-model` on Components\n Usually, the approach to handle interactive forms is through the use of v-model for input binding, which would bind the values of an input to reactive data. \n\n- **Form Input Binding with `v-model`**: The first input uses the `v-model` directive to bind the input field's value to the `inputText` data property. When the user types in the input field, the value of `inputText` is automatically updated, and vice versa.\n  - `v-model`: It creates a two-way binding between the input element and the component‚Äôs data. This ensures that the input reflects the data and the data reflects the input.\n\n- **Value Binding with `.lazy` Modifier**: In the second input, we use `v-bind:value.lazy` to bind the input‚Äôs value to `inputText`, but the update only happens when the input field loses focus (on `blur`). This is useful when you don't want to update the model continuously while typing, but rather when the user finishes editing.\n  - `.lazy`: The `.lazy` modifier makes the binding less reactive by only updating the bound property when the input loses focus (on `blur`). This is helpful in certain cases, like when you only need the value after the user has completed their input.\n\n- **Value Binding with `.number` Modifier**: The third input uses `v-bind:value.number` to bind the input to `inputNumber`. The `.number` modifier automatically converts the input value to a number, ensuring that the model stores a numeric value rather than a string.\n  - `.number`: This modifier parses the input value as a number. It is particularly useful when binding numeric inputs (e.g., `type=\"number\"`) and you want to ensure that the value is treated as a number in your data model.\n\n- **`v-model` on Custom Components**: The last part demonstrates how to use `v-model` with a custom component. The `v-model` on the `custom-input` component binds the `customInputValue` to the custom input component‚Äôs value. This allows two-way data binding between the parent component and the custom component.\n  - `v-model` on components: Vue automatically looks for the `modelValue` prop in custom components. The component should emit an `update:modelValue` event to trigger updates. This allows the parent to bind and update the value of custom components just like standard form elements. \n  - Also, you can use the `defineModel()` macro in the component. The value returned by defineModel() is a ref. This means that it acts as two-way binding between the parent value and a local one. So you can also bind this ref to a native element that uses v-model, further extending its use. \n\n## Summary of Modifiers and Binding Concepts:\n- **`v-model`**: Provides two-way data binding between form inputs and the data properties. It is the most common method for binding form elements (inputs, checkboxes, etc.) to component data.\n- **`.lazy` Modifier**: This modifier delays the update to the model property until the input loses focus (on `blur`). It is useful when you want to avoid constant updates to the data as the user types.\n- **`.number` Modifier**: Ensures that the value is treated as a number. This modifier is automatically applied to inputs with `type=\"number\"`, but can be manually added to other inputs as well.\n- **`v-model` on Custom Components**: With custom components, you can use `v-model` just like you would with native form elements. Ensure that your component listens for and emits the `update:modelValue` event to maintain two-way data binding."
    },
    {
      "title": "Watchers",
      "fileName": "Watchers",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <!-- Watcher: Watches changes in the 'inputText' data property -->\n    <input v-model=\"inputText\" placeholder=\"Type something...\" />\n    <p>Input Text: {{ inputText }}</p>\n    <p>Watcher Message: {{ watcherMessage }}</p>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watch } from 'vue'\n\n// Reactive data properties\nconst inputText = ref('')\nconst watcherMessage = ref('')\n\n// Watcher setup: watches 'inputText' for changes\nwatch(inputText, (newValue, oldValue) => {\n  watcherMessage.value = `Text changed from \"${oldValue}\" to \"${newValue}\"`\n})\n</script>",
      "description": "# Vue.js Watchers\nWatchers in Vue.js are used to perform specific actions when the value of a reactive data property changes. \n\n- **Watcher on `inputText`**: The `watch` function is used to watch the `inputText` property. When the `inputText` value changes, the provided callback function is triggered.\n  - **Watcher function signature**: The watcher accepts two arguments: the new value (`newValue`) and the old value (`oldValue`). This allows us to compare the new and old values to detect changes and act accordingly.\n  - **Watcher logic**: In this case, the watcher updates the `watcherMessage` data property to reflect a message showing how the `inputText` has changed.\n\n- **Reactivity in Watchers**: Vue automatically makes the `inputText` and `watcherMessage` properties reactive. The watcher will automatically trigger whenever the `inputText` property changes.\n\n- **Why use watchers**: Watchers are typically used when you need to perform side effects in response to data changes, such as making an API call, logging data, or modifying other properties when a certain value changes. While `computed` properties can be used for many reactivity tasks, watchers are more suitable for situations where you want to perform more complex or asynchronous operations.\n\n## Key Concepts:\n- **Reactivity**: Vue‚Äôs reactivity system allows the `inputText` and `watcherMessage` properties to be automatically updated and tracked when their values change.\n- **Watcher setup**: The `watch` function watches the `inputText` property and executes the callback function whenever `inputText` changes.\n- **Accessing new and old values**: Watchers provide both the `newValue` and `oldValue` of the watched property, giving you the ability to react to the specific change. \n\n ## Other Important Details: \n\n- While not seen in the example, watchers can also be *asynchronous*.  To do this, we add async before `(newVal, oldVal)`. These are mainly used if you have need to perform asynchronous operations from the watcher in response to a reactive change, if you need to debounce/delay a reaction, or if you need to wait for an operation within the watcher to complete (using await). \n- `oldVal` is actually optional. You are not required to provide oldVal unless you will expressly use it. \n- Watchers can run immediately on mount if you add `{ immediate: true }` after your watcher arrow function or handler.  \n\n## Use Cases for Watchers:\n\n Well, if you've been enjoying the typewriting animation on the code window, then you've been watching the watchers (redundancy, sorry!) at work. In this case, a watcher expects the code snippet to change (when you change topics or languages), so that it begins executing the deleting animation, and when that is done, it typewrites the new snippet. In more specific use cases: \n\n- Performing asynchronous operations (e.g., making an API call when a user types in a search field).\n- Watching for specific conditions and running code when those conditions are met, like so.\n- Watching deep changes in objects or arrays.\n\n## Alternatives to Watchers:\n- **`computed` properties**: Computed properties are often used for derived state, where you want to calculate a value based on other reactive properties. However, they are only useful when the value you're calculating can be derived purely from other reactive data. For more complex side effects, watchers are more appropriate.\n- **`methods`**: You can also react to changes through methods, especially when the action depends on user interactions (such as button clicks). However, methods don't automatically track changes in the data like watchers do.\n\n"
    },
    {
      "title": "WatchEffect (and also template refs)",
      "fileName": "AutoSaveDraftWithRef",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <input ref=\"draftInput\" placeholder=\"Start typing your draft...\" />\n    <p v-if=\"saveMessage\">{{ saveMessage }}</p>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watchEffect, onMounted } from 'vue'\n\nconst draftInput = ref(null) // Template ref for the input element\nconst saveMessage = ref('')\n\nfunction autoSaveDraft(content) {\n  // Simulate saving to a server or local storage\n  console.log('Auto-saving draft:', content)\n}\n\nonMounted(() => {\n  // Only start watching after the DOM is available\n  watchEffect(() => {\n    if (draftInput.value && draftInput.value.value.trim() !== '') {\n      autoSaveDraft(draftInput.value.value)\n      saveMessage.value = 'Draft saved at ' + new Date().toLocaleTimeString()\n    } else {\n      saveMessage.value = ''\n    }\n  })\n})\n</script>",
      "description": "# Vue.js `watchEffect` + Template Refs\n\nWatchEffect is essentially a simpler watcher that automatically tracks dependencies. It doesn't require you to specify what to watch, nor the newVal/oldVal. It will react to any reactive property accessed within its scope. In short, it reacts to what it reads. \n\n On the other hand, we also have template refs. These are a way to access a DOM element directly in vue. In the case where you need to, for example, automatically scroll to a certain element, auto-focus on an input, or in this case, auto-save a draft, you can use template refs. \n\n## Key Concepts:\n\n- **Template Refs**: By using `ref` on a template element (e.g., `ref=\"draftInput\"`), you can directly access and interact with the corresponding DOM node inside your script.\n- **Automatic Dependency Tracking**: `watchEffect` automatically tracks any reactive property accessed within its scope ‚Äî including the `.value` of a template ref.\n- **Immediate Execution**: The `watchEffect` runs right after setup (inside `onMounted` here to ensure the DOM is ready) and whenever dependencies change.\n- **Side Effects on DOM**: It's ideal when you want to monitor DOM-related state changes without manually wiring event listeners.\n\n## Why Use Template Refs Here?\n- Sometimes you need direct access to **raw DOM values** (for example, when you're outside standard `v-model` bindings).\n- It allows you to stay reactive and clean without manually handling input events.\n\n## Why `watchEffect` Over `watch`?\n- **Simplified Reaction**: You don't need to manually bind and unbind event listeners.\n- **Automatic Refresh**: The dependency (`draftInput.value.value`) is tracked automatically, and reactivity is maintained even if the DOM node changes.\n\n## Pseudocode Breakdown\n\n```pseudo\nWhen the input element is mounted:\n  Whenever the input value changes:\n    If the input is not empty:\n      Save the input text as a draft\n      Update a timestamped message\n    Else:\n      Clear the save message\n```\n\n"
    },
    {
      "title": "Parent-Child Communication",
      "fileName": "EventListeningExample",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <ChildComponent @updateMessage=\"handleUpdateMessage\" />\n    <p v-if=\"message\">Message from child: {{ message }}</p>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport ChildComponent from './ChildComponent.vue'\n\nconst message = ref('')\n\n// Event listener handler method in parent component\nfunction handleUpdateMessage(newMessage) {\n  message.value = newMessage\n}\n</script>\n\n<!-- ChildComponent.vue -->\n<template>\n  <button @click=\"sendMessage\">Send Message to Parent</button>\n</template>\n\n<script setup>\nimport { defineEmits } from 'vue'\n\n// Define the events this component can emit\nconst emit = defineEmits(['updateMessage'])\n\n// Method to emit the event when the button is clicked\nfunction sendMessage() {\n  emit('updateMessage', 'Hello from Child!')\n}\n</script>",
      "description": "# Vue.js Event Listening: Parent-Child Communication\n\nIn Vue, **event listening** allows components to communicate. For a parent to pass data to a child, its simple if you pass props to it. But what about the child? You need to define what the parent will expect from the child, and when it gets it, you must also define what will happen. \n\n### Key Concepts:\n\n- **Event Emission**: In Vue, a child component can **emit** an event using `this.$emit` (e.g.: `@click=\"$emit('updateMessage','Would you like some sausage?')\"`) or `defineEmits`. The parent component listens for this event using the **`@event-name`** directive.\n\n- **Event Handling**: When the parent component listens to the event, it calls a specific handler function. This function is responsible for reacting to the event and updating the component‚Äôs state.\n\n### Example Breakdown:\n\n- In the child component, the event `updateMessage` is emitted with `emit('updateMessage', newMessage)`. This can be done using `this.$emit` in the Options API or `defineEmits` in the Composition API.\n- The parent component listens to this event using `@updateMessage=\"handleUpdateMessage\"` and calls the `handleUpdateMessage` method whenever the event is emitted.\n- The `handleUpdateMessage` method updates the `message` data property in the parent, which is then reflected in the template.\n\n### Inline Event Handlers and Modifiers\n- You can also use inline event handlers to directly define the method calls in the template, e.g., `@click=\"incrementCounter\"`.\n- Event **modifiers** can be used to modify the event‚Äôs behavior:\n    - `.prevent`: Prevents the default action of the event.\n    - `.stop`: Stops the event from propagating.\n    - `.once`: Ensures the event is only triggered once.\n\n### `defineEmits`\n- The `defineEmits` function is part of the Vue Composition API and is used to define the events that the component can emit. It's like declaring the events in a contract, so the parent knows what to listen for.\n- **Usage**: You call `defineEmits` with an array of event names, and the component can emit those events using the `emit` function.\n- This is an alternative to using `this.$emit` in the Options API. It is often used inside the `setup` function for better readability and organization.\n\n### Practical Use Case:\n- Child components might emit events like `input`, `click`, or custom events such as `update`, `submit`, and `delete`. The parent component listens to these events and responds appropriately.\n\nThis pattern allows you to build more modular and reusable components by establishing clear event-based communication between them."
    },
    {
      "title": "Ancestor-Descendant Comms",
      "fileName": "ProvideInjectExample",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <ChildComponent />\n  </div>\n</template>\n\n<script setup>\nimport ChildComponent from './ChildComponent.vue'\nimport { provide } from 'vue'\n\n// Provide data to be injected into child components\nprovide('message', 'Hello from Parent Component!')\n</script>\n\n<!-- ChildComponent.vue -->\n<template>\n  <p>{{ message }}</p>\n</template>\n\n<script setup>\nimport { inject } from 'vue'\n\n// Inject the provided value from the parent component\nconst message = inject('message')\n</script>",
      "description": "# Provide and Inject in Vue.js\nParent to child is simple enough. But what if gramps needs to tell something to his grandson? What if there are more descendant levels? You don't want to make a prop train. So instead, we use other forms of communication. The `provide` and `inject` API allows a parent component to provide data or functions to its descendants, without needing to pass props through each intermediate component. This is particularly useful in deeply nested components where passing props would become cumbersome.\n\n### Key Concepts:\n\n- **`provide`**: The `provide` function is used in the parent component to make data or functions available to all descendant components, regardless of how deep the component hierarchy is.\n- **`inject`**: The `inject` function is used in a child component to access the provided data or functions from an ancestor component.\n\n### Example Breakdown:\n\n1. **Parent Component** (`ProvideInjectExample.vue`):\n   - The parent component uses the `provide` function to make a value (`'Hello from Parent Component!'`) available to all its descendants.\n   - This value is accessible to any child component through the `inject` function.\n\n2. **Child Component** (`ChildComponent.vue`):\n   - The child component uses the `inject` function to retrieve the `message` provided by the parent.\n   - The child simply accesses this data as a reactive reference (`message`), which automatically updates when the provided value changes.\n\n### When to Use `Provide` and `Inject`:\n- **Deeply Nested Components**: When you need to share data or methods between a parent and deeply nested children without passing props manually at each level.\n- **Global Data in a Component Tree**: When there‚Äôs data that all components need to share (e.g., theme, user session, etc.), `provide` and `inject` can make this process cleaner and more manageable.\n\n### Limitations:\n- The `provide` and `inject` relationship is one-way. It allows data to flow downwards, but not upwards. To update the provided value, it needs to be done in the parent component.\n- Unlike `props`, `provide` and `inject` are not reactive unless the provided data itself is reactive (e.g., using Vue's `reactive` or `ref`).\n\n### Example of Reactivity with `provide` and `inject`:\n```vue\n// Parent component providing a reactive data\n<script setup>\nimport { provide, ref } from 'vue'\nconst message = ref('Hello from Parent Component!')\nprovide('message', message)\n</script>\n\n// Child component injecting the reactive data\n<script setup>\nimport { inject } from 'vue'\nconst message = inject('message')\n</script>\n```\nIn this case, since the `message` is a `ref`, the child component will automatically react to changes in the parent's `message`.\n\n### Summary:\n- **`provide`** and **`inject`** provide a way for deeply nested components to access data or methods without relying on props.\n- These are useful for managing global state in component trees but are limited in terms of reactivity and control compared to props and events.  \n\n ### Some other details: \n- It is recommended to keep any mutations to reactive data within the component that provides it. This is because the component that injects it will not be able to react to changes made to the provided data. \n- You can wrap the provided value with readonly() e.g.:`provide ('read-only-count', readonly(count))`. This ensures that the data passed through provide cannot be mutated by the injector.  \n- You can also use `provide` and `inject` with a default value, which will be used if no value is provided by an ancestor. \n- You can also use `provide` and `inject` with a function, which allows you to provide a new value each time the function is called. This is useful for providing a new value based on some condition or state. \n- You can also use `provide` and `inject` with a symbol, which allows you to provide a unique value that cannot be overridden by other components. This is useful for providing a value that should be unique across the entire application. \n\n"
    },
    {
      "title": "Reusables",
      "fileName": "ComposableCustomDirectiveAndPluginExample",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <h1>{{ countdown }}</h1>\n    <button @click=\"startTimer\">Start Countdown</button>\n    <button @click=\"logMessage\">Log Message</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport { useCountdown } from './useCountdown'\n\n// Using composable to manage countdown logic\nconst { countdown, startTimer } = useCountdown()\n\n// Global plugin method for logging messages\nconst logMessage = () => {\n  // Using the global plugin's log method to format the message\n  app.config.globalProperties.$log('This is a logged message!')\n}\n</script>\n\n<!-- CustomDirective.vue -->\n<template>\n  <div v-hover-bg>Hover over me!</div>\n</template>\n\n<script setup>\nimport { defineDirective } from 'vue'\n\n// Custom Directive to change background color on hover\ndefineDirective('hover-bg', {\n  beforeMount(el) {\n    el.addEventListener('mouseenter', () => {\n      el.style.backgroundColor = 'lightblue'\n    })\n    el.addEventListener('mouseleave', () => {\n      el.style.backgroundColor = ''\n    })\n  },\n})\n</script>\n\n<!-- Plugin File: plugins/loggerPlugin.js -->\n<script>\n// Define the plugin that adds a global logging method\nthe global method will log messages in a custom format\nexport default function loggerPlugin(app) {\n  app.config.globalProperties.$log = function (message) {\n    const timestamp = new Date().toLocaleString();\n    console.log(`[${timestamp}] Log: ${message}`);\n  };\n}\n</script>",
      "description": "# Composables, Custom Directives, and Plugins in Vue\n So far, we know components and maybe even views are reusable. How about other structures?\n\n### 1. **Composable**\nThe `useCountdown` composable manages the countdown logic. Composables are reusable functions that can encapsulate state and logic. By defining them separately from components, you can easily reuse the countdown logic in different components throughout the app.\n\n Generally, the way to do this is to separate the logic into a `.js` (or your preferred filetype) which will export the desired function or behavior. This can then be imported into a component for use of a specific exported behaviour. You generally see this a lot with `helpers.js` files, which contain helper functions that can be used across an application. \n\nIn the component, the `countdown` value is reactive and will update the DOM whenever it changes. The `startTimer` function is responsible for starting the countdown.\n\n### 2. **Custom Directive**\nThe `v-hover-bg` custom directive changes the background color of an element when it is hovered over. Vue allows you to create your own directives to handle custom DOM manipulation. Here, the directive listens for the `mouseenter` and `mouseleave` events to apply and remove the background color.\n\n You generally want to do this only when you can only achieve certain functionality by directly manipulating the DOM. This could be because you need to add a specific event listener, or because you need to manipulate the DOM in a way that is not possible with standard Vue directives. Otherwise, prefer using built-in directives or the reactivity system. \n\nThis directive is registered with the `defineDirective` function in the `<script setup>` block and is used in the template as `v-hover-bg`.\n\n### 3. **Plugin**\nThe `loggerPlugin` is a Vue plugin that adds a global method `$log` to the app instance. A plugin is a function that can add global functionality to Vue, such as utility functions, properties, or methods that need to be accessed globally across components.\n\n You see them in the main.js file, where you can register them with `app.use(pluginName)`. This allows you to add global functionality to your Vue app, such as adding methods to `globalProperties`, or handling third-party libraries in a unified way. Since we are talking about reusables, this also means that you can create your own plugins to add functionality to your app. \n\nIn this case, `$log` formats a message with a timestamp and logs it to the console. By registering the plugin with `app.use(loggerPlugin)`, the method is available throughout the application.\n\n### Key Concepts:\n- **Composable**: A function that encapsulates reusable logic and state. It provides a way to separate concerns and make code more modular.\n- **Custom Directives**: Allow you to define behavior and event handling directly on DOM elements. Useful for adding custom, low-level functionality like event listeners.\n- **Plugin**: A way to add global functionality to your Vue app, such as adding methods to `globalProperties`, or handling third-party libraries in a unified way.\n\n### Why These Concepts are Useful:\n- **Composable**: Allows for easy reuse of logic, improving maintainability and reducing duplication.\n- **Custom Directives**: Simplify the handling of direct DOM manipulations, enabling more powerful templates.\n- **Plugin**: Provides a way to inject global functionality or third-party tools, making them available throughout your app without repeating code.\n\nBy using composables, directives, and plugins together, you can keep your codebase clean, modular, and maintainable."
    },
    {
      "title": "Vuex and State Management",
      "fileName": "store",
      "fileType": ".js",
      "code": "import { createStore } from 'vuex';\n\nconst store = createStore({\n  state: {\n    count: 0,\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    },\n  },\n});\n\nexport default store;",
      "description": "# Vuex Store\nVuex is a state management library for Vue.js applications. It provides a centralized store for all components in an application, enabling predictable, trackable, and organized state management.\n\n### Key Concepts:\n- **Importing Vuex**: The `createStore` function is imported from the `vuex` package (for Vue 3; Vuex 4+).\n- **Creating Store**: `createStore` is called with an object that defines:\n  - **state**: where your application's reactive data lives.\n  - **mutations**: synchronous functions to directly modify state.\n  - **actions** (optional): asynchronous operations that can commit mutations.\n  - **getters** (optional): computed-like properties based on state.\n- **State**: The `state` object contains the shared, reactive data (for example, a `count` property).\n- **Mutations**: The `mutations` object contains methods to directly change state. They must be synchronous (e.g., `increment` increases the `count`).\n- **Actions**: Actions allow you to perform asynchronous operations (like API calls) and then commit mutations.\n- **Getters**: Getters are like computed properties for your store, letting you derive data from state in a cached and reactive way.\n- **Exporting Store**: The store instance is exported so it can be provided to the Vue application (`main.js`) via `app.use(store)`.\n\n### Why Use Vuex?\n- **Centralized State**: Instead of scattering shared state across components, Vuex puts it in one place.\n- **Predictable Mutations**: Since state can only be mutated through defined mutations, your app's state transitions are always explicit and trackable.\n- **Devtools Integration**: Vue Devtools lets you inspect and time-travel through state changes when using Vuex.\n- **Scalable Organization**: Large applications benefit from Vuex‚Äôs module system, allowing you to split store logic into modules.\n\n### Basic Vuex Flow:\n1. A **component dispatches an action** or **commits a mutation**.\n2. The **mutation** updates the **state**.\n3. **Components reactively update** based on the new state.\n\nVuex is ideal for medium to large projects where components need to share or coordinate state in a structured and traceable way. \n ### Still too abstract? \n\nImagine a shopping cart in an online store: \n- Any product page in the app can add items to the cart. \n- All around the app you can see the cart icon and how many items it has \n- When you get to checkout, you get to see all the items you previously added, as well as all their prices, and the discounts and totals applied. \n\n Instead of passing props and emitting events from all over the place, Vuex can manage the cart's state (items, total price) and provide mutations to add or remove items. Components can dispatch actions to update the cart, and the UI will automatically reflect those changes. \n\n By having State Management, you get: \n- Centralized global storage. \n- Interaction between this storage and any component that needs to update or read it. \n- Teammate respect and s*x appeal. *(not guaranteed)* \n- Cleanliness‚ú®.  \n\n### Alternatives to Vuex:\n- **Composition API**: For smaller applications, you can use the Composition API with `ref()` and `reactive()` to manage state without Vuex.\n- **Provide/Inject**: For passing data between components without prop drilling.\n- **Pinia**: A lightweight alternative to Vuex that is gaining popularity for its simplicity and ease of use."
    },
    {
      "title": "Animation Techniques",
      "fileName": "TransitionsAndAnimationExample",
      "fileType": ".vue",
      "code": "<template>\n  <div>\n    <button @click=\"toggleShow\">Toggle Element</button>\n    <transition name=\"fade\">\n      <p v-if=\"show\" class=\"fade\">This element will fade in and out</p>\n    </transition>\n    <transition-group name=\"list\" tag=\"ul\">\n      <li v-for=\"item in items\" :key=\"item.id\" class=\"list-item\">{{ item.text }}</li>\n    </transition-group>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst show = ref(false)\nconst toggleShow = () => {\n  show.value = !show.value\n}\n\nconst items = ref([\n  { id: 1, text: 'Item 1' },\n  { id: 2, text: 'Item 2' },\n  { id: 3, text: 'Item 3' }\n])\n</script>\n\n<style scoped>\n.fade-enter-active, .fade-leave-active {\n  transition: opacity 1s ease;\n}\n.fade-enter, .fade-leave-to {\n  opacity: 0;\n}\n\n.list-item {\n  padding: 10px;\n  margin: 5px;\n  background-color: #f0f0f0;\n  border-radius: 5px;\n  transition: background-color 0.3s ease;\n}\n\n.list-enter-active, .list-leave-active {\n  transition: transform 0.3s ease;\n}\n.list-enter, .list-leave-to {\n  transform: translateY(30px);\n  opacity: 0;\n}\n</style>",
      "description": "# Transitions, Transition Groups, and Animation Techniques in Vue\nVue's transition system provides hooks for applying animations when elements enter, leave, or change state. Most of the animations you see here are provided by built-in directives. \n\n### 1. **Basic Transition with `v-if` and `transition`**\nThe `transition` element wraps a single element, applying CSS animations or transitions to it when it enters or leaves the DOM. In this example, a `<p>` element fades in and out when `show` is toggled. The `fade` classes are applied based on the element's lifecycle (entering, leaving), and transitions are applied using CSS.\n\n- **`fade-enter-active`** and **`fade-leave-active`** define the transition duration and timing.\n- **`fade-enter`** and **`fade-leave-to`** define the starting and ending states of the element during the transition.\n\n### 2. **Transition Group with `v-for`**\n`transition-group` allows for animated transitions when elements are added or removed in a list, useful for dynamic lists or ordered animations. Here, the `transition-group` is used with a list of items rendered with `v-for`. Each item has a `key` that ensures that Vue can track individual elements in the list during transitions.\n\n- **`list-enter-active`** and **`list-leave-active`** control the timing and transition of the entire group.\n- **`list-enter`** and **`list-leave-to`** define how each list item enters and exits (e.g., a slide from below with opacity fade).\n\n### 3. **CSS Animation Techniques**\nCSS transitions and animations are used to manage how elements animate when they enter or leave. In this case, we're using the `opacity` property to fade elements and the `transform` property to create a sliding effect. Vue adds `enter` and `leave` classes at appropriate times, allowing you to control the animation timing and styles.\n\n### Why Use Transitions and Transition Groups?\n- **Transitions** allow you to create smooth animations when elements are added, removed, or updated in the DOM. This makes UI changes feel more dynamic and less jarring to the user.\n- **Transition Groups** are great for handling complex animations on lists of elements, such as when items are added or removed dynamically. You can animate entire groups of items, making them visually cohesive.\n- **CSS animations and transitions** offer a powerful way to add visual interest to your UI, improving user experience and guiding users through the interface.\n\n### Key Concepts:\n- **`transition`**: A directive used to apply transitions to a single element when it enters or leaves the DOM.\n- **`transition-group`**: A directive used for applying transitions to a list of elements. It is useful for animating lists that change dynamically.\n- **CSS Transitions**: You can use CSS to define the animation behavior, including timing, easing, and effects (e.g., fade, slide).\n- **`v-if` and `v-for`**: Used together with transitions to control which elements should be included in the DOM and how they should animate.\n\n### Why These Concepts Are Useful:\n- **Transition**: Helps create a more polished and user-friendly interface by adding smooth animations.\n- **Transition Groups**: Allow for complex animations on lists or multiple elements, ensuring that items are not just removed, but disappear with a smooth animation.\n- **CSS Animations**: Enable the ability to add more sophisticated effects, like color changes or scaling, without needing JavaScript.\n\nVue makes it easy to incorporate complex animations in your app by leveraging transitions and transition groups to provide a richer user experience."
    }
  ]
}
