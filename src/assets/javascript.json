{
  "language": "JavaScript",
  "documentationUrl": "https://developer.mozilla.org/en-US/docs/Web/JavaScript",
  "snippets": [
    {
      "title": "Javascript Starter",
      "fileName": "hello-world",
      "fileType": ".js",
      "code": "const hello = \"Hello gracklewontsing!\";\nconsole.log(hello);",
      "description": "# Hello World\nJavaScript's `console.log()` function sends messages to the browser's console — a common tool for debugging or displaying output. Strings like `\"Hello gracklewontsing!\"` are enclosed in quotes and assigned to variables with `const` to prevent reassignment. \n\n Javascript runs in your browser! If you use your browser's console, you can insert JavaScript code directly. \n\n```javascript\nconst hello = \"Hello gracklewontsing!\";\nconsole.log(hello);\n```\n\nThis code will print `Hello gracklewontsing!` to the console.\n",
      "output": "Hello gracklewontsing!"
    },
    {
      "title": "Data Types - Primitives",
      "fileName": "primitives",
      "fileType": ".js",
      "code": "const str = \"hello\";\nconst num = 42;\nconst isOn = true;\nconst nothing = null;\nconst notDefined = undefined;\n\nconsole.log(typeof str, typeof num, typeof isOn);",
      "description": "# Primitive Data Types\nJavaScript has several basic (primitive) types: `string`, `number`, `boolean`, `null`, and `undefined`. These types represent singular values. `typeof` is used to check the type of any variable. Note that `null` is technically an object due to a historical quirk in the language.",
      "output": "string number boolean"
    },
    {
      "title": "Non-Primitive Data Types",
      "fileName": "non-primitive-types",
      "fileType": ".js",
      "code": "// Non-primitive types are objects and collections:\n\n// 1. Object\nconst user = { name: \"Lark\", age: 27 };\n\n// 2. Array\nconst birds = [\"Wren\", \"Grackle\", \"Lark\"];\n\n// 3. Function\nfunction greet(name) {\n  return `Hello, ${name}!`;\n}\n\n// 4. Date\nconst now = new Date();\n\n// 5. Map\nconst map = new Map();\nmap.set(\"key\", \"value\");\n\n// 6. Set\nconst set = new Set([1, 2, 2, 3]);\n\nconsole.log(user.name);         // \"Lark\"\nconsole.log(birds[0]);          // \"Wren\"\nconsole.log(greet(\"Grackle\")); // \"Hello, Grackle!\"\nconsole.log(now.getFullYear());\nconsole.log(map.get(\"key\"));   // \"value\"\nconsole.log([...set]);         // [1, 2, 3]",
      "description": "**Non-primitive data types** (also called reference types) in JavaScript include objects, arrays, functions, dates, maps, and sets. They do not store actual values directly, but rather references to locations in memory. This means that if you copy them, you're copying the reference—not the actual data.\n\n- **Object**: A collection of key-value pairs.\n- **Array**: An ordered list of items.\n- **Function**: A reusable block of code.\n- **Date**: Represents a specific moment in time.\n- **Map**: Stores key-value pairs with any type of key.\n- **Set**: Stores unique values (no duplicates).\n\nThese types are flexible and form the backbone of working with complex data in JavaScript.",
      "output": "\"Lark\", \"Wren\", \"Hello, Grackle!\", [current year], \"value\", [1, 2, 3]"
    },
    {
      "title": "Shallow vs Deep Copy",
      "fileName": "copy-types",
      "fileType": ".js",
      "code": "// Original object\nconst original = {\n  name: \"Grackle\",\n  traits: { color: \"black\", sings: false }\n};\n\n// 1. Shallow copy using spread syntax\nconst shallowCopy = { ...original };\nshallowCopy.traits.color = \"blue\"; // Because traits is a nested structure, the shallow copy let's it be modified.\n\n// 2. Deep copy using structuredClone (modern and safest)\nconst deepCopyStructured = structuredClone(original);\ndeepCopyStructured.traits.color = \"green\"; // Safe: original not affected\n\n// 3. Deep copy using JSON method (older workaround)\nconst deepCopyJSON = JSON.parse(JSON.stringify(original));\ndeepCopyJSON.traits.color = \"red\"; // Also safe (but has limitations)\n\nconsole.log(original.traits.color);        // \"blue\"\nconsole.log(deepCopyStructured.traits.color); // \"green\"\nconsole.log(deepCopyJSON.traits.color);       // \"red\"\n",
      "description": "**Shallow vs Deep Copy**\n\nWhen copying objects or arrays in JavaScript, it’s important to know whether you’re copying just the top layer (shallow) or every nested structure (deep).\n\n- ✅ **Shallow Copy**: Only the top-level values are copied. Nested objects or arrays still reference the **same memory**.\n  - Examples: `{ ...obj }`, `Object.assign({}, obj)`\n  - Risk: Changing a nested property in the copy affects the original.\n\n- ✅ **Deep Copy**: All levels of the object are copied recursively.\n  - `structuredClone(obj)`: The safest built-in method (modern browsers only). Handles most data types.\n  - `JSON.parse(JSON.stringify(obj))`: A classic workaround, but:\n    - ❌ Loses functions, `undefined`, `Date`, `Map`, `Set`, `Symbol`, and circular references.\n\nIn the example above:\n- `shallowCopy` modifies the original object's `traits`.\n- `deepCopyStructured` and `deepCopyJSON` do **not** affect the original, because they truly clone everything inside.",
      "output": "\"blue\" (original was changed by shallow copy), \"green\" and \"red\" (deep copies are safe)"
    },
    {
      "title": "Variables - var vs let vs const",
      "fileName": "let-const-var",
      "fileType": ".js",
      "code": "var legacy = \"I'm var!\";\nlet counter = 1;\nconst name = \"Grackle\";\n\ncounter++;\n// name = \"Another Name\"; // ❌ Throws an error\n\nfunction showVars() {\n  console.log(legacy, counter, name);\n}\nshowVars();",
      "description": "# Variables: var, let, and const\n`var` is the original way to declare variables in JavaScript, but it is function-scoped and hoisted, meaning it's accessible (but `undefined`) before it's defined. `let` is block-scoped and can be reassigned. `const` is also block-scoped but cannot be reassigned. Prefer `let` and `const` in modern JavaScript for better clarity and safety.  Use `var` only when specific behaviors like hoisting or global exposure are desired.",
      "output": "I'm var! 2 Grackle"
    },
    {
      "title": "Conditionals - if/else Statements",
      "fileName": "if-else",
      "fileType": ".js",
      "code": "const age = 17;\n\nif (age >= 18) {\n  console.log(\"You may vote.\");\n} else {\n  console.log(\"You are too young to vote.\");\n}",
      "description": "# Conditional Logic\nJavaScript uses `if`, `else if`, and `else` to execute code conditionally. Use comparison operators (like `>=`, `===`, etc.) to check values. The above code checks if `age` is 18 or older and logs a message accordingly.",
      "output": "You are too young to vote."
    },
    {
      "title": "Arrays, Sets, and Loops",
      "fileName": "arrays-sets-loop",
      "fileType": ".js",
      "code": "const fruits = [\"apple\", \"banana\", \"cherry\"];\nconst uniqueFruits = new Set([\"apple\", \"banana\", \"cherry\", \"banana\"]);\n\nfor (let fruit of fruits) {\n  console.log(fruit);\n}\n\nfor (let fruit of uniqueFruits) {\n  console.log(fruit);\n}",
      "description": "# Arrays, Sets, and Iteration\nArrays in JavaScript store ordered lists of values, and the `for...of` loop is used to iterate directly over the values in an iterable (such as an array). In the given example, each `fruit` in the `fruits` array is printed using `console.log`.\n\nA **Set** is a new data structure introduced in ES6 that stores unique values of any type. Sets automatically remove duplicate entries. In the example, `uniqueFruits` is a Set containing the same fruits but with `banana` only appearing once due to its uniqueness property. The `for...of` loop can also be used to iterate over Sets in the same way as arrays, but Sets guarantee that no duplicate values are printed.",
      "output": "apple\nbanana\ncherry\napple\nbanana\ncherry"
    },
    {
      "title": "Functions - Return vs Void",
      "fileName": "functions",
      "fileType": ".js",
      "code": "// Function that returns a value\nfunction greet(name) {\n  return `Hello, ${name}`;\n}\n\n// Function with side-effect only (void)\nfunction logGreeting(name) {\n  console.log(`Hello, ${name}`);\n}\n\nconsole.log(greet(\"Grackle\"));\nlogGreeting(\"Grackle\");",
      "description": "# Functions in JavaScript\nFunctions are reusable blocks of logic. A function that returns a value (like `greet`) gives you a result you can store or reuse. A void function (like `logGreeting`) performs an action (a *side effect*) without returning a value. Template literals (`` `Hello, ${name}` ``) are used to embed variables in strings.",
      "output": "Hello, Grackle\nHello, Grackle"
    },
    {
      "title": "Promises - Asynchronous Basics",
      "fileName": "promise-basics",
      "fileType": ".js",
      "code": "const wait = ms => new Promise(resolve => setTimeout(resolve, ms));\n\nwait(500).then(() => {\n  console.log(\"Waited half a second\");\n});",
      "description": "# Promises and Async Flow\nA `Promise` represents a future value or completion of an asynchronous task. `setTimeout` is used here to delay code execution. We wrap it in a `Promise` so we can use `.then()` to continue the logic once the delay ends. This is a foundation for asynchronous JavaScript programming.\n\n🔄 **Asynchronous calls like `setTimeout` are delegated to the browser (or Node environment)**, which manages the delay in the background. Once complete, the callback is pushed into the JavaScript event loop to be executed later.\n\n🧠 **Promises and `await` use the microtask queue**, meaning their continuation happens as soon as the current call stack clears—**before** any macrotask like `setTimeout`. This ensures predictable sequencing in asynchronous flows.",
      "output": "Waited half a second"
    },
    {
      "title": "Event Loop - Understanding JS Concurrency",
      "fileName": "event-loop",
      "fileType": ".js",
      "code": "// This example demonstrates how tasks are handled in the event loop\n\nconsole.log('Start of Script');\n\nsetTimeout(() => {\n  console.log('Timeout Task');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise Task');\n});\n\nconsole.log('End of Script');",
      "description": "# The Event Loop: Understanding JavaScript's Concurrency Model\n\nJavaScript uses a single-threaded execution model, which means that it can only execute one task at a time. The event loop is the mechanism that handles asynchronous operations in JavaScript. It manages how JavaScript handles tasks such as `setTimeout`, `Promises`, user events, and other asynchronous code.\n\n## Key Concepts of the Event Loop\n\n### 1. Call Stack\nThe **call stack** is where the currently executing code is kept. It operates in a Last-In-First-Out (LIFO) manner. When a function is called, it is added to the stack. When the function finishes, it is removed. If the stack is full (for example, due to infinite recursion), the JavaScript engine will throw a **stack overflow** error.\n\n### 2. Task Queue\nThe **task queue** (or event queue) is where asynchronous operations like `setTimeout`, I/O tasks, and events are placed after they have finished execution. Once the call stack is empty, the event loop checks the task queue and pushes the next task onto the stack.\n\n### 3. Microtask Queue\nThe **microtask queue** holds tasks such as `Promises` that resolve asynchronously. Microtasks have a higher priority than regular tasks in the task queue. After each task from the task queue is executed, the event loop checks the microtask queue and processes any microtasks that are pending before it continues with the task queue.\n\n### 4. Event Loop\nThe **event loop** is a continuous process that monitors the call stack and the task queues. The event loop operates by executing the following steps:\n\n1. It checks the call stack. If it is empty, it proceeds.\n2. It looks at the microtask queue. If any tasks are pending, it executes them first.\n3. It then checks the task queue. If there are any tasks in it, it moves them to the call stack to execute.\n\n### Example Execution Flow\nIn the code below, we observe the event loop in action:\n\n```js\nconsole.log('Start of Script');\n\nsetTimeout(() => {\n  console.log('Timeout Task');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise Task');\n});\n\nconsole.log('End of Script');\n```\n\nHere’s what happens step by step:\n\n1. **'Start of Script'** is logged immediately because it is part of the synchronous code that runs directly in the call stack.\n2. The `setTimeout` function is called, but its callback is scheduled to run after the specified delay. Even though the delay is `0`, it goes to the task queue.\n3. A `Promise` is created and resolved immediately, placing its `.then()` callback in the microtask queue.\n4. **'End of Script'** is logged as the next synchronous code.\n5. The event loop checks the microtask queue (which has the `Promise` task) and executes it, logging **'Promise Task'**.\n6. Finally, the event loop checks the task queue, finds the `setTimeout` callback, and logs **'Timeout Task'**.\n\n### Order of Execution\nThe final output of the code will be:\n\n```\nStart of Script\nEnd of Script\nPromise Task\nTimeout Task\n```\n\nThis demonstrates how the event loop prioritizes microtasks over tasks in the task queue.\n\n## Conclusion\nThe event loop is essential for JavaScript’s asynchronous behavior. It enables the language to handle long-running operations like I/O or network requests without freezing the UI, by allowing tasks to run in the background and pushing them to the queue when appropriate. By understanding the event loop and its components (call stack, task queue, microtask queue), you can better predict and optimize the behavior of asynchronous code in JavaScript.",
      "output": "Start of Script\nEnd of Script\nPromise Task\nTimeout Task"
    },
    {
      "title": "Promise.all & Micro/Macrotasks",
      "fileName": "promise-all-microtasks",
      "fileType": ".js",
      "code": "// Promise.all - waits for all to finish (or rejects if any fail)\nconst a = Promise.resolve(1);\nconst b = Promise.resolve(2);\nconst c = Promise.resolve(3);\n\nPromise.all([a, b, c]).then(values => {\n  console.log(\"Promise.all result:\", values); // [1, 2, 3]\n});\n\n// Microtask vs Macrotask demo\nqueueMicrotask(() => console.log(\"microtask: runs after current call\"));\n\nsetTimeout(() => console.log(\"macrotask: runs after delay\"), 0);\n\nconsole.log(\"sync: runs first\");",
      "description": "**`Promise.all()`** & **Task Queues in JavaScript**\n\n### ✅ `Promise.all()`\n`Promise.all()` takes an array of promises and returns a **single promise** that:\n- ✅ Resolves when **all** promises resolve (in order).\n- ❌ Rejects immediately if **any** promise fails.\n\nUse this when you want to run promises in parallel and wait for all of them to finish.\n\n---\n\n### 🧠 Microtasks vs Macrotasks\nJavaScript runs code in **phases**, coordinated by the **event loop**:\n\n1. **Synchronous code** runs first.\n2. Then the **microtask queue** runs (before the browser does anything else).\n3. Finally, **macrotasks** run (like timers, rendering, or I/O).\n\n💡 **Promises** and **`async`/`await`** callbacks are always scheduled in the **microtask queue** — this ensures they run immediately after the current call stack, *before* any `setTimeout` or `setInterval`.\n\nIn this example:\n- `console.log(\"sync\")` runs first.\n- Then the microtask (`queueMicrotask(...)`) runs.\n- Then the `.then()` callback from `Promise.all` runs — also a microtask.\n- Finally, the `setTimeout` (a macrotask) runs.\n\n```\n[ call stack ] → [ microtasks (await, .then) ] → [ macrotasks (setTimeout) ]\n```\n\nThis order is crucial when you're handling chained promises or `await` — they execute quickly, but not *immediately* — they wait for the synchronous stack to clear first.",
      "output": "sync: runs first\nmicrotask: runs after current call\nPromise.all result: [1, 2, 3]\nmacrotask: runs after delay"
    },
    {
      "title": "Promise States and Resolutions",
      "fileName": "promise-states",
      "fileType": ".js",
      "code": "const wait = ms => new Promise((resolve, reject) => {\n  if (ms < 0) {\n    reject('Time cannot be negative');\n  } else {\n    setTimeout(resolve, ms);\n  }\n});\n\nwait(-500)\n  .then(() => {\n    console.log('Waited half a second');\n  })\n  .catch(error => {\n    console.error('Error:', error);\n  })\n  .finally(() => {\n    console.log('Promise has settled, regardless of resolution or rejection');\n  });",
      "description": "# Promise States: Resolve, Reject, Catch, and Finally\nA `Promise` can be in one of three states:\n- **Pending**: Initial state, neither resolved nor rejected.\n- **Resolved**: The asynchronous task completed successfully.\n- **Rejected**: The asynchronous task failed, and an error was returned.\n\nThe `.then()` method runs when a promise is successfully resolved, executing the provided success callback. However, if a promise is rejected (such as when an error occurs in the asynchronous operation), the `.catch()` method handles the error. In this example, if the time is negative, the promise is rejected and the `.catch()` method catches the error message (`'Time cannot be negative'`), which is then logged.\n\nThe `.finally()` method ensures that a block of code runs after the promise has either resolved or rejected. This is useful for cleanup tasks, such as hiding a loading spinner, closing a file, or other similar actions that need to happen after the promise is done, regardless of success or failure.\n\n### Key Concepts:\n- **`.catch()`**: Catches and handles errors from rejected promises. It helps manage errors in asynchronous code flow by allowing you to respond to failures.\n- **Rejected Promises**: When a promise is rejected, it transitions to the **rejected** state. The rejection value (error) is passed to the `.catch()` handler.\n\nIn this case, when the promise is rejected due to a negative time value, the `.catch()` block logs the error message.\n",
      "output": "Error: Time cannot be negative\nPromise has settled, regardless of resolution or rejection"
    },
    {
      "title": "Even More about Promises",
      "fileName": "promise-advanced",
      "fileType": ".js",
      "code": "// Promise Chaining\nconst task1 = () => new Promise(resolve => setTimeout(resolve, 500, 'Task 1 Completed'));\nconst task2 = () => new Promise(resolve => setTimeout(resolve, 300, 'Task 2 Completed'));\n\ntask1()\n  .then(result1 => {\n    console.log(result1);\n    return task2();\n  })\n  .then(result2 => {\n    console.log(result2);\n  })\n  .catch(error => console.error('Error:', error));\n\n// Promise.allSettled()\nconst task3 = Promise.resolve('Task 3 Completed');\nconst task4 = Promise.reject('Task 4 Failed');\n\nPromise.allSettled([task3, task4])\n  .then(results => {\n    results.forEach(result => {\n      if (result.status === 'fulfilled') {\n        console.log('Success:', result.value);\n      } else {\n        console.log('Failure:', result.reason);\n      }\n    });\n  });\n\n// Promise.race()\nconst task5 = new Promise(resolve => setTimeout(resolve, 500, 'Task 5 Completed'));\nconst task6 = new Promise(resolve => setTimeout(resolve, 300, 'Task 6 Completed'));\n\nPromise.race([task5, task6])\n  .then(result => console.log('First task to complete:', result));\n\n// Promise.any()\nconst task7 = Promise.reject('Task 7 Failed');\nconst task8 = Promise.resolve('Task 8 Completed');\nconst task9 = Promise.reject('Task 9 Failed');\n\nPromise.any([task7, task8, task9])\n  .then(result => console.log('First successful task:', result))\n  .catch(error => console.log('No successful promises:', error));",
      "description": "# Promise Basics and Advanced Methods\nThis example demonstrates the following key promise concepts:\n\n- **Promise Chaining**: Allows sequential execution of promises where each `.then()` returns a new promise or value to pass on to the next.\n\n- **Promise.allSettled()**: Waits for all promises to settle, regardless of success or failure. It returns the status (`fulfilled` or `rejected`) and the result or reason for each promise.\n\n- **Promise.race()**: Resolves as soon as one of the promises resolves or rejects. It returns the result of the first promise that settles.\n\n- **Promise.any()**: Resolves as soon as one of the promises resolves successfully. If all promises are rejected, it returns an `AggregateError`.\n\nThese methods are powerful tools for working with multiple asynchronous operations and controlling the flow of execution in your code.",
      "output": "Task 1 Completed\nTask 2 Completed\nSuccess: Task 3 Completed\nFailure: Task 4 Failed\nFirst task to complete: Task 6 Completed\nFirst successful task: Task 8 Completed"
    },
    {
      "title": "Async Iterators - Are you tired yet?",
      "fileName": "async-iterators",
      "fileType": ".js",
      "code": "// Creating an Async Iterator\nasync function* fetchData() {\n  yield 'First Data';\n  await new Promise(resolve => setTimeout(resolve, 500));\n  yield 'Second Data';\n  await new Promise(resolve => setTimeout(resolve, 300));\n  yield 'Third Data';\n}\n\n// Using the Async Iterator\n(async () => {\n  const dataIterator = fetchData();\n  for await (let data of dataIterator) {\n    console.log(data);\n  }\n})();",
      "description": "# Async Iterators\nAsync Iterators allow you to iterate through asynchronous data, using `async function*` to create an asynchronous generator.\n\n- The `yield` statement is used to produce values, just like with normal iterators, but it can also be used with `await` to pause execution and wait for a promise to resolve.\n\n- The `for await...of` loop is used to consume an async iterator and process each yielded value. This loop waits for each promise to resolve before moving to the next iteration.\n\nIn this example, the iterator generates data with pauses in between, mimicking asynchronous operations like fetching data from a server.",
      "output": "First Data\nSecond Data\nThird Data"
    },
    {
      "title": "Promise Cancellation",
      "fileName": "promise-cancellation",
      "fileType": ".js",
      "code": "// Create an AbortController\nconst controller = new AbortController();\nconst signal = controller.signal;\n\n// A function that simulates a task, accepting an abort signal\nfunction fetchData(signal) {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => resolve('Data fetched'), 5000);\n\n    // Check if the signal has been aborted\n    signal.addEventListener('abort', () => {\n      clearTimeout(timeout);\n      reject('Request cancelled');\n    });\n  });\n}\n\n// Start fetching data\nfetchData(signal)\n  .then(result => console.log(result))\n  .catch(error => console.log(error));\n\n// Simulate cancelling the request after 2 seconds\nsetTimeout(() => controller.abort(), 2000);",
      "description": "# Promise Cancellation using AbortController\nIn JavaScript, promises do not have a built-in cancellation mechanism. However, you can implement cancellation manually using the `AbortController`.\n\n- `AbortController` is an API that allows you to signal that an operation should be aborted.\n- You can associate the controller's `signal` with a function, and listen for the `abort` event to cancel the operation.\n\nIn this example, `fetchData` simulates an asynchronous operation that resolves after 5 seconds. However, we cancel it after 2 seconds using the `AbortController`. The `abort` event clears the timeout and rejects the promise with a cancellation message.",
      "output": "Request cancelled"
    },
    {
      "title": "Generators",
      "fileName": "generator-functions",
      "fileType": ".js",
      "code": "// Generator Function Example\n\nfunction* countUpTo(limit) {\n  let count = 1;\n  while (count <= limit) {\n    yield count;\n    count++;\n  }\n}\n\nconst counter = countUpTo(5);\n\nconsole.log(counter.next()); // { value: 1, done: false }\nconsole.log(counter.next()); // { value: 2, done: false }\nconsole.log(counter.next()); // { value: 3, done: false }\nconsole.log(counter.next()); // { value: 4, done: false }\nconsole.log(counter.next()); // { value: 5, done: false }\nconsole.log(counter.next()); // { value: undefined, done: true }",
      "description": "# Generator Functions\nGenerator functions are special functions in JavaScript that can pause their execution and later resume it, allowing you to work with asynchronous or incremental data in a more manageable way.\n\n## Syntax\nTo define a generator function, you use the `function*` syntax. Inside the generator, you use the `yield` keyword to pause the execution and return a value. Every time the `next()` method is called on the generator object, execution continues from where it left off, yielding the next value.\n\n### Key Concepts\n1. **Generator Functions (`function*`)**\n   - A generator function is defined using the `function*` keyword. It allows the function to be paused and resumed, producing a sequence of values on demand.\n   - It returns a generator object, which conforms to the iterator protocol, meaning it has a `.next()` method that controls the flow of execution.\n\n2. **The `yield` Keyword**\n   - The `yield` statement is used to pause the generator function and return a value. The function can then be resumed from the `yield` point on subsequent calls to `.next()`.\n   - `yield` can return any type of value (string, number, object, etc.), and execution can continue from where the generator was paused.\n\n3. **The `next()` Method**\n   - The `.next()` method is used to resume the execution of the generator function and retrieve the next yielded value. It returns an object with two properties:\n     - `value`: the value returned by the `yield` expression.\n     - `done`: a boolean that indicates whether the generator has completed execution.\n\n### Example Walkthrough\nConsider the following generator function, `countUpTo(limit)`: It generates numbers from 1 up to a given limit, yielding one number at a time.\n\n```js\nfunction* countUpTo(limit) {\n  let count = 1;\n  while (count <= limit) {\n    yield count;\n    count++;\n  }\n}\n```\n\n- When the function is called, it does not execute immediately. Instead, it returns a generator object.\n- The generator object has a `.next()` method, which starts or resumes the execution of the generator function.\n- On each call to `.next()`, the generator executes until it hits a `yield` statement. It then pauses and returns the value that was yielded, as well as a `done` status indicating whether the generator has finished.\n\n### Example Code\n```js\nconst counter = countUpTo(5);\n\nconsole.log(counter.next()); // { value: 1, done: false }\nconsole.log(counter.next()); // { value: 2, done: false }\nconsole.log(counter.next()); // { value: 3, done: false }\nconsole.log(counter.next()); // { value: 4, done: false }\nconsole.log(counter.next()); // { value: 5, done: false }\nconsole.log(counter.next()); // { value: undefined, done: true }\n```\n\nIn this example:\n- The generator yields numbers from 1 to 5, returning them one by one each time `.next()` is called.\n- The final call to `.next()` returns `{ value: undefined, done: true }`, indicating that the generator has completed.\n\n### Use Cases\nGenerators are useful for a variety of purposes, including:\n1. **Lazy Evaluation**: Generators allow you to lazily compute values one at a time, which is useful when working with large data sets or streams of data.\n2. **Asynchronous Programming**: With the help of libraries like `co` or the `async`/`await` pattern in newer JavaScript versions, generators can be used to write asynchronous code in a more synchronous-looking style.\n3. **Infinite Sequences**: Generators are great for producing infinite sequences of values, like random number generators or Fibonacci numbers, without running into performance issues.\n\n### Conclusion\nGenerator functions are a powerful tool in JavaScript for handling sequences of values. They allow for lazy evaluation, enabling you to pause and resume execution as needed. This makes them ideal for dealing with streams of data or implementing more complex asynchronous flows.",
      "output": "{ value: 1, done: false }\n{ value: 2, done: false }\n{ value: 3, done: false }\n{ value: 4, done: false }\n{ value: 5, done: false }\n{ value: undefined, done: true }"
    },
    {
      "title": "while and do...while",
      "fileName": "while-loop",
      "fileType": ".js",
      "code": "let n = 0;\n\nwhile (n < 3) {\n  console.log(\"While loop count:\", n);\n  n++;\n}\n\nlet m = 0;\ndo {\n  console.log(\"Do-while loop count:\", m);\n  m++;\n} while (m < 3);",
      "description": "# Looping with while and do...while\nJavaScript offers different kinds of loops. A `while` loop runs **as long as** its condition is true. If the condition is initially false, the code block never runs.\n\nA `do...while` loop, however, **runs at least once**, then checks the condition.\n\nThis distinction matters when the loop's logic must run regardless of the starting condition, such as prompting a user once before validating input.",
      "output": "While loop count: 0\nWhile loop count: 1\nWhile loop count: 2\nDo-while loop count: 0\nDo-while loop count: 1\nDo-while loop count: 2"
    },
    {
      "title": "Arrow Functions",
      "fileName": "arrow-functions",
      "fileType": ".js",
      "code": "const square = x => x * x;\nconst greet = name => `Hi, ${name}`;\n\nconsole.log(square(4));\nconsole.log(greet(\"Grackle\"));",
      "description": "# Arrow Functions and Implicit Return\nArrow functions (`=>`) are a concise way to define functions. When the function has a single expression, **you can skip the braces and the `return` keyword** — this is called an *implicit return*.\n\nIf the function takes one parameter, you can also omit the parentheses around it.\n- `x => x * x` is shorthand for `function(x) { return x * x; }`\n- name => \\`Hi, ${name}\\` returns a greeting string.\n\nUse this for short, readable logic — but prefer full syntax when clarity or multi-step logic is needed.",
      "output": "16\nHi, Grackle"
    },
    {
      "title": "Arrays and Essential Methods",
      "fileName": "array-methods-overview",
      "fileType": ".js",
      "code": "// 1. map - Transform values\nconst numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n\n// 2. filter - Select specific values\nconst ages = [12, 18, 20, 15, 30];\nconst adults = ages.filter(age => age >= 18);\nconsole.log(adults); // [18, 20, 30]\n\n// 3. reduce - Collapse to a single value\nconst scores = [10, 20, 30];\nconst total = scores.reduce((acc, curr) => acc + curr, 0);\nconsole.log(total); // 60\n\n// 4. find - Get first matching value\nconst users = [\n  { id: 1, name: \"Grackle\" },\n  { id: 2, name: \"Wren\" },\n  { id: 3, name: \"Lark\" }\n];\nconst result = users.find(user => user.name === \"Wren\");\nconsole.log(result); // { id: 2, name: \"Wren\" }\n\n// 5. some - Check if any pass\nconst nums = [3, 5, 7, 8];\nconst hasEven = nums.some(num => num % 2 === 0);\nconsole.log(hasEven); // true\n\n// 6. every - Check if all pass\nconst allAges = [22, 34, 19];\nconst allAdults = allAges.every(age => age >= 18);\nconsole.log(allAdults); // true",
      "description": "This file demonstrates six essential JavaScript array methods for working with collections:\n\n1. **`map()`** – Transforms each element and returns a new array. Useful for applying changes to all items.\n2. **`filter()`** – Returns a new array with only the elements that match a condition. Great for narrowing data.\n3. **`reduce()`** – Combines all elements into a single value. Often used for totals, averages, or building objects.\n4. **`find()`** – Returns the first element that matches a condition. Unlike `filter`, it returns just one item (or `undefined`).\n5. **`some()`** – Checks if **any** element matches a condition. Returns a boolean.\n6. **`every()`** – Checks if **all** elements pass a test. Also returns a boolean.\n \nNotice the use of arrow functions to further reduce the amount of code.\nThese methods are powerful tools for transforming, filtering, searching, and analyzing arrays without writing explicit loops.",
      "output": "[2, 4, 6, 8], [18, 20, 30], 60, {\"id\": 2, \"name\": \"Wren\"}, true, true"
    },
    {
      "title": "Other Array Methods",
      "fileName": "array-methods-sampler",
      "fileType": ".js",
      "code": "// includes\nconst birds = [\"Grackle\", \"Wren\", \"Lark\"];\nconsole.log(birds.includes(\"Wren\")); // true\nconsole.log(birds.includes(\"Sparrow\")); // false\n\n// splice\nbirds.splice(1, 1, \"Sparrow\");\nconsole.log(birds); // [\"Grackle\", \"Sparrow\", \"Lark\"]\n\n// sort\nconst numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers); // [1, 2, 3, 4, 5]\n\n// concat\nconst birds1 = [\"Grackle\", \"Wren\"];\nconst birds2 = [\"Lark\", \"Sparrow\"];\nconst allBirds = birds1.concat(birds2);\nconsole.log(allBirds); // [\"Grackle\", \"Wren\", \"Lark\", \"Sparrow\"]\n\n// fill\nconst filled = new Array(5).fill(0);\nconsole.log(filled); // [0, 0, 0, 0, 0]\n\n// flat\nconst nested = [[1, 2], [3, 4]];\nconsole.log(nested.flat()); // [1, 2, 3, 4]\n\n// reverse\nconst reversed = [1, 2, 3, 4];\nreversed.reverse();\nconsole.log(reversed); // [4, 3, 2, 1]\n\n// slice\nconst sliced = [1, 2, 3, 4, 5].slice(1, 4);\nconsole.log(sliced); // [2, 3, 4]",
      "description": "# Array Method Sampler\nThis example demonstrates eight common array methods:\n\n- `includes()` checks if an element exists.\n- `splice()` modifies contents by removing/replacing items.\n- `sort()` organizes numeric values in ascending order.\n- `concat()` merges multiple arrays.\n- `fill()` creates an array filled with a static value.\n- `flat()` flattens a nested array.\n- `reverse()` reverses an array in place.\n- `slice()` extracts a subsection without modifying the original.\n\nGreat for practicing basic transformations and manipulations on arrays.",
      "output": "true\nfalse\n[\"Grackle\", \"Sparrow\", \"Lark\"]\n[1, 2, 3, 4, 5]\n[\"Grackle\", \"Wren\", \"Lark\", \"Sparrow\"]\n[0, 0, 0, 0, 0]\n[1, 2, 3, 4]\n[4, 3, 2, 1]\n[2, 3, 4]"
    },
    {
      "title": "Dot and Bracket Notation",
      "fileName": "object-access",
      "fileType": ".js",
      "code": "const bird = {\n  name: \"Grackle\",\n  canSing: false,\n  \"wing-span\": 35\n};\n\nconsole.log(bird.name); // dot notation\nconsole.log(bird[\"wing-span\"]); // bracket notation",
      "description": "# JavaScript Objects\nObjects are collections of key-value pairs. They’re used to represent structured data. In the example, `bird` is an object with three properties.\n\nJavaScript offers two main ways to access object properties:\n- **Dot notation** (`bird.name`) is simpler but only works with keys that are valid variable names (no spaces or hyphens).\n- **Bracket notation** (`bird[\"wing-span\"]`) allows any string as a key — including those with special characters.\n\nThis makes bracket notation more flexible, especially when the property name is dynamic or unusual.",
      "output": "Grackle\n35"
    },
    {
      "title": "Object Inspection",
      "fileName": "object-utils",
      "fileType": ".js",
      "code": "const bird = {\n  name: \"Grackle\",\n  color: \"black\",\n  sings: false\n};\n\nconsole.log(Object.keys(bird));     // [\"name\", \"color\", \"sings\"]\nconsole.log(Object.values(bird));   // [\"Grackle\", \"black\", false]\nconsole.log(Object.entries(bird));  // [[\"name\", \"Grackle\"], [\"color\", \"black\"], [\"sings\", false]]",
      "description": "JavaScript provides three handy methods to inspect object structure:\n\n1. **`Object.keys(obj)`** – Returns an array of **property names** (keys).\n2. **`Object.values(obj)`** – Returns an array of the **property values**.\n3. **`Object.entries(obj)`** – Returns an array of `[key, value]` pairs — useful for iteration or conversion to `Map`.\n\nAll three methods work on plain objects and make it easy to explore or manipulate the contents.",
      "output": "[\"name\", \"color\", \"sings\"], [\"Grackle\", \"black\", false], [[\"name\", \"Grackle\"], [\"color\", \"black\"], [\"sings\", false]]"
    },
    {
      "title": "Chaining Array Methods",
      "fileName": "chaining-fmr",
      "fileType": ".js",
      "code": "const birds = [\n  { name: \"Grackle\", wingspan: 17 },\n  { name: \"Wren\", wingspan: 6 },\n  { name: \"Lark\", wingspan: 13 },\n  { name: \"Sparrow\", wingspan: 8 }\n];\n\nconst result = birds\n  .filter(bird => bird.wingspan >= 10)          // Step 1: Keep only birds with wingspan ≥ 10\n  .map(bird => bird.name.toUpperCase())         // Step 2: Transform names to uppercase\n  .reduce((str, name) => str + name + \"! \", \"\"); // Step 3: Concatenate names into a string\n\nconsole.log(result);",
      "description": "# Method Chaining: `filter()`, `map()`, and `reduce()`\nYou can chain array methods to process data in stages:\n\n1. `filter()` narrows the list to birds with a wingspan ≥ 10.\n2. `map()` transforms each of those birds’ names to uppercase.\n3. `reduce()` combines the result into a single string, separated by `!`.\n\nThis approach makes your data flow readable and expressive — each method transforms or narrows the list step-by-step.",
      "output": "GRACKLE! LARK! "
    },

    {
      "title": "Map",
      "fileName": "map-create-access",
      "fileType": ".js",
      "code": "const birdMap = new Map();\n\nbirdMap.set(\"Grackle\", \"Noisy\");\nbirdMap.set(\"Wren\", \"Tiny\");\nbirdMap.set(\"Lark\", \"Melodic\");\n\nconsole.log(birdMap.get(\"Wren\")); // Tiny\nconsole.log(birdMap.has(\"Sparrow\")); // false",
      "description": "# `Map`\n`Map` lets you store key-value pairs, and keys can be any type.\n\n- `set(key, value)` adds or updates an entry.\n- `get(key)` retrieves a value.\n- `has(key)` checks if a key exists.\n\nUnlike objects, Maps preserve insertion order and allow any data type as a key.",
      "output": "Tiny\nfalse"
    },
    {
      "title": "Map forEach",
      "fileName": "map-foreach",
      "fileType": ".js",
      "code": "const birdMap = new Map([\n  [\"Grackle\", \"Noisy\"],\n  [\"Wren\", \"Tiny\"],\n  [\"Lark\", \"Melodic\"]\n]);\n\nbirdMap.forEach((description, bird) => {\n  console.log(`${bird} is ${description}`);\n});",
      "description": "# `Map.forEach()`\nAllows iteration over entries in a Map. Callback receives `value` first, then `key`.",
      "output": "Grackle is Noisy\nWren is Tiny\nLark is Melodic"
    },
    {
      "title": "Map - Objects as Keys",
      "fileName": "map-object-keys",
      "fileType": ".js",
      "code": "const birdInfo = new Map();\n\nconst bird1 = { name: \"Grackle\" };\nconst bird2 = { name: \"Wren\" };\n\nbirdInfo.set(bird1, { size: \"Large\", color: \"Black\" });\nbirdInfo.set(bird2, { size: \"Small\", color: \"Brown\" });\n\nconsole.log(birdInfo.get(bird1).color);",
      "description": "# Map with Objects as Keys\nIn JavaScript, `Map` allows you to use **objects** (or any other reference types) as keys. This is a major distinction from plain objects, where keys must be strings or symbols. Using objects as keys is useful when you need to associate metadata with different instances of objects or when the key's identity is tied to the object rather than its string representation.\n\nIn the example above, `bird1` and `bird2` are objects representing different birds. The `Map` stores metadata about these birds (size and color). We can retrieve this metadata using the object itself as a key (e.g., `birdInfo.get(bird1)`), which returns the associated value.\n\nThis is possible because `Map` uses the object’s **reference** as the key, not the object’s content. This allows for dynamic key-value pairs where the key is not just a string, but a complex data structure.",
      "output": "Black"
    },

    {
      "title": "Map to Array",
      "fileName": "map-to-array",
      "fileType": ".js",
      "code": "const birdMap = new Map([\n  [\"Grackle\", \"Noisy\"],\n  [\"Wren\", \"Tiny\"]\n]);\n\nconst asArray = [...birdMap];\nconsole.log(asArray);\n\nconst justKeys = [...birdMap.keys()];\nconsole.log(justKeys);",
      "description": "# Convert Map to Array\nMaps store key-value pairs and preserve insertion order. You can easily convert a Map to an array using either the spread operator (`...`) or `Array.from()`. When you convert a Map, the result will be an array of `[key, value]` pairs.\n\nFor example, the expression `[...birdMap]` converts the Map into an array with two sub-arrays (key-value pairs). If you only need the keys or values from the Map, you can use the `keys()` and `values()` methods, which return an iterator. Using the spread operator or `Array.from()` will convert these iterators into arrays.\n\nThis approach can be useful when you want to manipulate the Map data in a more array-friendly way, such as filtering, sorting, or using array-specific methods like `.map()` or `.reduce()`.",
      "output": "[[\"Grackle\", \"Noisy\"], [\"Wren\", \"Tiny\"]]\n[\"Grackle\", \"Wren\"]"
    },
    {
      "title": "Restructuring",
      "fileName": "destructuring-rest-spread",
      "fileType": ".js",
      "code": "// Destructuring\nconst person = { name: 'John', age: 30, location: 'New York' };\nconst { name, age } = person;\nconsole.log(name, age);  // John 30\n\n// Array Destructuring\nconst colors = ['red', 'blue', 'green'];\nconst [first, second] = colors;\nconsole.log(first, second);  // red blue\n\n// Rest Operator (Objects)\nconst { name, ...rest } = person;\nconsole.log(name);  // John\nconsole.log(rest);  // { age: 30, location: 'New York' }\n\n// Rest Operator (Arrays)\nconst [firstColor, ...remainingColors] = colors;\nconsole.log(firstColor);  // red\nconsole.log(remainingColors);  // [ 'blue', 'green' ]\n\n// Spread Operator (Objects)\nconst newPerson = { ...person, job: 'Developer' };\nconsole.log(newPerson);  // { name: 'John', age: 30, location: 'New York', job: 'Developer' }\n\n// Spread Operator (Arrays)\nconst newColors = [...colors, 'yellow', 'purple'];\nconsole.log(newColors);  // [ 'red', 'blue', 'green', 'yellow', 'purple' ]",
      "description": "# Restructuring and Rest/Spread Operators\nJavaScript provides convenient ways to extract values from objects and arrays, as well as manipulate them using the **Rest** and **Spread** operators.\n\n### Destructuring\nDestructuring allows you to unpack values from arrays or properties from objects into distinct variables, making your code cleaner and easier to work with.\n\n1. **Object Destructuring**: You can extract values from an object by specifying the keys you want to assign to variables. For example:\n   ```js\n   const person = { name: 'John', age: 30, location: 'New York' };\n   const { name, age } = person;\n   console.log(name, age);  // John 30\n   ```\n   Here, we unpack `name` and `age` directly from the `person` object.\n\n2. **Array Destructuring**: Similarly, you can unpack values from arrays. For example:\n   ```js\n   const colors = ['red', 'blue', 'green'];\n   const [first, second] = colors;\n   console.log(first, second);  // red blue\n   ```\n   We assign `first` and `second` to the first and second elements of the `colors` array.\n\n### Rest Operator\nThe **Rest Operator** allows you to collect the remaining properties or elements from objects or arrays into a new variable.\n\n1. **Object Rest**: With the rest operator in an object, you can collect all the remaining properties into a new object:\n   ```js\n   const { name, ...rest } = person;\n   console.log(name);  // John\n   console.log(rest);  // { age: 30, location: 'New York' }\n   ```\n   Here, the `name` property is extracted, and the rest of the properties are captured in the `rest` object.\n\n2. **Array Rest**: You can also use the rest operator with arrays to capture the remaining elements:\n   ```js\n   const [firstColor, ...remainingColors] = colors;\n   console.log(firstColor);  // red\n   console.log(remainingColors);  // [ 'blue', 'green' ]\n   ```\n   The first element is unpacked into `firstColor`, while the remaining elements go into the `remainingColors` array.\n\n### Spread Operator\nThe **Spread Operator** allows you to spread elements or properties from an existing array or object into a new one.\n\n1. **Object Spread**: You can create a new object by copying all the properties of an existing object and then adding new properties:\n   ```js\n   const newPerson = { ...person, job: 'Developer' };\n   console.log(newPerson);  // { name: 'John', age: 30, location: 'New York', job: 'Developer' }\n   ```\n   The spread operator copies all properties from `person` into `newPerson`, while adding the new `job` property.\n\n2. **Array Spread**: Similarly, you can spread the elements of one array into another:\n   ```js\n   const newColors = [...colors, 'yellow', 'purple'];\n   console.log(newColors);  // [ 'red', 'blue', 'green', 'yellow', 'purple' ]\n   ```\n   The spread operator combines `colors` with the new `yellow` and `purple` colors to form a new array.\n\n### Use Cases\n- **Destructuring** is great for reducing verbosity and improving code readability when accessing elements of arrays or objects.\n- **Rest and Spread Operators** are useful for manipulating objects and arrays without directly mutating the originals, making your code easier to maintain and safer to work with.\n\n### Conclusion\nThe **Rest** and **Spread** operators, along with **Destructuring**, provide powerful syntax for simplifying and improving JavaScript code. They make it easier to work with complex data structures, such as arrays and objects, by providing ways to extract and manipulate their contents more efficiently.",
      "output": "John 30\nred blue\nJohn\n{ age: 30, location: 'New York' }\nred\n[ 'blue', 'green' ]\n{ name: 'John', age: 30, location: 'New York', job: 'Developer' }\n[ 'red', 'blue', 'green', 'yellow', 'purple' ]"
    },
    {
      "title": "Immutable Data Structures",
      "fileName": "immutable-data",
      "fileType": ".js",
      "code": "// Naive mutation (mutable):\nconst original = { name: \"Rook\", level: 5 };\nconst mutated = original;\nmutated.level = 6; // This changes 'original' too\n\nconsole.log(original.level); // 6 — unexpected if immutability was assumed\n\n// Immutable update (via spread):\nconst immutable = { ...original, level: 7 };\nconsole.log(original.level); // Still 6\nconsole.log(immutable.level); // 7\n\n// Nested immutability (manual or with libraries like Immer):\nconst player = { name: \"Ava\", stats: { hp: 100, mp: 50 } };\nconst shallowCopy = { ...player };\nshallowCopy.stats.hp = 80; // Still mutates nested object\n\n// Deep copy to achieve immutability:\nconst deepCopy = { ...player, stats: { ...player.stats, hp: 60 } };\nconsole.log(player.stats.hp); // 80 (was mutated earlier)\nconsole.log(deepCopy.stats.hp); // 60",
      "description": "# Immutable Data Structures in JavaScript\n**Immutability** means once a data structure is created, it cannot be changed. Instead, you create and work with modified *copies* of the data.\n\nIn JavaScript, most objects and arrays are **mutable by default**, meaning changes to one reference can affect another. This is risky in larger applications — especially in state management — where unintended side effects can arise.\n\n## Why It Matters\n- **Predictable state**: Helps track changes more easily.\n- **Undo/redo support**: Immutability enables time-travel debugging.\n- **React and Redux**: Depend heavily on immutability for performance and correct updates.\n\n## Techniques for Immutability\n- **Spread operator** (`...`) for shallow copies.\n- **`Object.assign()`** for older environments.\n- **Deep copying** manually or via tools (e.g., `structuredClone`, `lodash.cloneDeep`).\n- **Libraries like Immer, Immutable.js** to simplify safe updates.\n\n## Caveats\n- Spread only creates **shallow copies**. For nested structures, changes to inner objects still mutate the original.\n- `structuredClone()` (browser API) or libraries help create **deeply immutable structures**.\n\nImmutability makes state logic safer and helps avoid bugs caused by shared references — especially when used with async or reactive systems like React.",
      "output": "6\n6\n7\n80\n60"
    },
    {
      "title": "Function Hoisting",
      "fileName": "function-hoisting",
      "fileType": ".js",
      "code": "// Example 1: Function Declaration\n\nconsole.log(greet());\n\nfunction greet() {\n  return \"Hello, World!\";\n}\n\n// Example 2: Function Expression\n\ntry {\n  console.log(sayHi());\n} catch (error) {\n  console.log(error.message);\n}\n\nconst sayHi = function() {\n  return \"Hi there!\";\n};",
      "description": "# Function Hoisting\nIn JavaScript, **function declarations** are hoisted to the top of their scope, meaning they are available to be called before they appear in the code. However, **function expressions** (such as functions assigned to variables) are not hoisted in the same way.\n\n### Function Declarations\nFunction declarations are hoisted in their entirety. This means that the function definition (i.e., its code) is moved to the top of the scope during the execution phase of JavaScript's execution context. This allows you to call the function before it's written in the code.\n\n### Function Expressions\nFunction expressions, on the other hand, are **not** hoisted in the same way. The function assigned to a variable is hoisted, but the assignment (the actual function definition) happens at runtime. If you try to call the function before it's defined, you will encounter an error.\n\nIn the example, `greet()` can be called before its definition, but `sayHi()` cannot be called before its definition because it's a function expression.\n\n**Output**:\n- `greet()` works because it's a function declaration.\n- `sayHi()` throws an error because it's a function expression, and the function is not assigned before the call.",
      "output": "Hello, World!\nCannot read property 'message' of undefined"
    },
    {
      "title": "Closures",
      "fileName": "closures",
      "fileType": ".js",
      "code": "// Example 1: Basic Closure\n\nfunction outer() {\n  let counter = 0;\n\n  return function inner() {\n    counter++;\n    return counter;\n  };\n}\n\nconst increment = outer();\nconsole.log(increment()); // 1\nconsole.log(increment()); // 2\nconsole.log(increment()); // 3\n\n// Example 2: Closure with Private Data\n\nfunction createCounter() {\n  let count = 0;\n  return {\n    increment: function() { count++; return count; },\n    decrement: function() { count--; return count; },\n    getCount: function() { return count; }\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter.increment()); // 1\nconsole.log(counter.increment()); // 2\nconsole.log(counter.decrement()); // 1\nconsole.log(counter.getCount()); // 1",
      "description": "# Closures\nA **closure** is a function that retains access to variables from its **lexical scope**, even when the function is executed outside of that scope.\n\n### How Closures Work\nWhen a function is created inside another function, the inner function gets access to the outer function's variables, even after the outer function has finished executing. This means that the inner function 'remembers' the environment in which it was created, which is referred to as a closure.\n\n### Example 1: Basic Closure\nIn this example, the `inner` function has access to the `counter` variable from the `outer` function, even after `outer` has finished executing. Every time `increment` is called, it increments the `counter` variable, and the function 'remembers' its previous state.\n\n### Example 2: Closure with Private Data\nHere, we use closures to create private variables. The `count` variable is not directly accessible from outside the `createCounter` function, but we provide methods (`increment`, `decrement`, `getCount`) that can manipulate and access it. This allows us to maintain encapsulation and privacy of data.\n\nClosures allow us to create stateful functions, with the ability to preserve and modify their internal state even after the outer function has finished executing.",
      "output": "1\n2\n3\n1\n2\n1\n1"
    },
    {
      "title": "Web Workers",
      "fileName": "web-workers",
      "fileType": ".js",
      "code": "// Create a new Web Worker\nconst worker = new Worker('worker.js');\n\n// Send data to the worker\nworker.postMessage({ num1: 5, num2: 10 });\n\n// Listen for messages from the worker\nworker.onmessage = function(event) {\n  console.log('Result from worker: ', event.data);\n};\n\n// worker.js file content\nself.onmessage = function(event) {\n  const { num1, num2 } = event.data;\n  self.postMessage(num1 + num2); // Sending result back to the main thread\n};",
      "description": "# Web Workers\nWeb Workers are a way to run JavaScript code in the background, in a separate thread from the main execution context of a web page. They allow you to offload computationally expensive tasks to a separate thread, preventing the user interface from freezing or becoming unresponsive. This is particularly useful for tasks such as large data processing, complex calculations, and operations that may take a long time to complete.\n\nWhen using Web Workers, you essentially spin off a new thread where JavaScript code can run independently. The main thread can communicate with the worker thread using a system of messages. This means that while the worker is running its task, the main UI thread remains free to handle user interactions and update the user interface without delay.\n\nThe key advantage of Web Workers is that they allow you to perform heavy computations without blocking the UI. For example, in a web application that processes large datasets or performs complex calculations, using a worker to handle the processing allows the page to remain responsive and not become slow or unresponsive.\n\nIn the provided example, a `Worker` is created, which runs a separate JavaScript file (`worker.js`). The main thread sends data to the worker using `postMessage()`, and the worker performs a task (in this case, adding two numbers) and then sends the result back to the main thread using `postMessage()`. The main thread listens for the worker's response via the `onmessage` event handler.\n\n### Use Cases\n1. **Data Processing**: Web Workers are ideal for handling large amounts of data without blocking the UI. For instance, you could use a Web Worker to parse and process large JSON files, perform complex image manipulations, or analyze large datasets, while the main thread remains free to handle user interactions.\n2. **Asynchronous Tasks**: When working with time-consuming tasks like animations, calculations, or downloading files, Web Workers let you run those tasks in the background, keeping the UI responsive.\n3. **Complex Computations**: Web Workers are commonly used for scientific computations or mathematical calculations that require significant processing power. Rather than running these computations on the main thread and risking a slow or unresponsive application, the computations can be offloaded to a worker thread.\n4. **Parallelizing Tasks**: You can use multiple Web Workers to split a large task into smaller chunks and process them concurrently. This can significantly improve the speed of operations like searching through large datasets or running simulations in parallel.\n\n### Limitations\nWhile Web Workers are powerful, they do have some limitations. For instance, they don't have direct access to the DOM or the window object, so you can't manipulate the user interface directly from within a worker. Instead, workers communicate with the main thread through message-passing, which can be a bit more cumbersome than direct DOM manipulation.\n\n### Conclusion\nWeb Workers are a powerful tool for offloading intensive tasks to background threads. They allow you to keep your web applications responsive and performant by preventing heavy computations from blocking the UI thread. By using message-passing for communication between the main thread and workers, you can create highly efficient web applications capable of handling complex or time-consuming operations without sacrificing user experience.",
      "output": "Result from worker:  15"
    },
    {
        "title": "Service Workers",
        "fileName": "service-worker",
        "fileType": ".js",
        "code": "// service-worker.js\nself.addEventListener('install', event => {\n  console.log('Service Worker installing...');\n  event.waitUntil(\n    caches.open('v1').then(cache => {\n      return cache.addAll([\n        '/', '/index.html', '/styles.css', '/main.js'\n      ]);\n    })\n  );\n});\n\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request).then(response => {\n      return response || fetch(event.request);\n    })\n  );\n});\n\n// main.js (registration code)\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/service-worker.js')\n      .then(reg => console.log('Service Worker registered:', reg.scope))\n      .catch(err => console.error('Service Worker registration failed:', err));\n  });\n}",
        "description": "# Service Workers\nA **Service Worker** is a script that runs in the background, separate from the main page, enabling features like:\n\n- **Offline access** by caching files\n- **Background sync**\n- **Push notifications**\n- Intercepting **network requests**\n\nThey act as a programmable proxy between your app and the network. Once registered, they can cache essential assets and serve them even when the user is offline.\n\n### Lifecycle:\n- `install` – Cache assets\n- `activate` – Clean up old caches (not shown above)\n- `fetch` – Intercepts network requests\n\nService Workers follow a **promise-based API** and are **event-driven**. They must be served over **HTTPS** and only control pages from their own origin/scope.\n\nIn the example:\n- On install, files are added to cache.\n- On fetch, it serves cached content if available, falling back to the network.",
        "output": "Console Output (when loaded):\nService Worker registered: /\nService Worker installing..."
      }
,      
    {
      "title": "Memoization ",
      "fileName": "memoization",
      "fileType": ".js",
      "code": "function memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache[key]) {\n      console.log('Fetching from cache for:', args);\n      return cache[key];\n    }\n    console.log('Calculating result for:', args);\n    const result = fn(...args);\n    cache[key] = result;\n    return result;\n  };\n}\n\n// Example function to memoize\nconst slowFactorial = (n) => {\n  if (n <= 1) return 1;\n  return n * slowFactorial(n - 1);\n};\n\nconst memoizedFactorial = memoize(slowFactorial);\nconsole.log(memoizedFactorial(5));  // Calculating result\nconsole.log(memoizedFactorial(5));  // Fetching from cache\nconsole.log(memoizedFactorial(6));  // Calculating result",
      "description": "# Memoization\nMemoization is an optimization technique used to improve the performance of functions by caching their results based on input parameters. The idea is simple: if a function has been called before with the same arguments, its result can be stored and reused instead of recalculating it. This can significantly speed up programs, especially when dealing with expensive or frequently repeated computations.\n\nIn this example, we have a basic `memoize` function that takes a function `fn` as an argument and returns a new function that caches the results of the original function. When the new function is called with a set of arguments, it first checks if the result for those arguments is already cached. If so, it returns the cached result, avoiding redundant calculations. If not, it calculates the result, stores it in the cache, and returns the result.\n\n### Example Breakdown\nIn the example, the `slowFactorial` function computes the factorial of a number recursively. By default, recursive functions like this one can be slow when called repeatedly with the same arguments because each call results in redundant calculations. Memoization helps here by caching results of previous calls. The `memoizedFactorial` function wraps `slowFactorial` with the memoization logic.\n\n- On the first call to `memoizedFactorial(5)`, the result is computed and stored in the cache.\n- On the second call with the same argument, `memoizedFactorial(5)`, the result is fetched directly from the cache.\n- When a new argument, `memoizedFactorial(6)`, is passed, the calculation is done and stored for future use.\n\nThis reduces the need to recalculate the factorial for `5` repeatedly and improves performance in scenarios where the same function might be called multiple times with the same input.\n\n### Use Cases\n1. **Recursive Functions**: Memoization is particularly effective for optimizing recursive functions that are called repeatedly with the same parameters, such as calculating Fibonacci numbers or factorials.\n2. **Expensive Calculations**: For functions that perform resource-intensive calculations (e.g., image processing or database queries), memoization can significantly reduce the need to redo the same work.\n3. **Caching Web Requests**: Memoization can be used to store the results of API calls so that the same request isn't sent repeatedly when the response is already known.\n4. **Dynamic Programming**: Memoization is often used as a technique in dynamic programming to solve problems that have overlapping subproblems by storing the results of solved subproblems and reusing them later.\n\n### Limitations\n- **Memory Consumption**: Memoization relies on caching results, which can increase memory usage. In scenarios where there are a large number of unique inputs, this can cause the cache to grow significantly.\n- **Cache Management**: Depending on how the cache is implemented, there may be cases where stale or outdated values are returned. Cache eviction strategies (e.g., least-recently-used) can be implemented to mitigate this.\n\n### Conclusion\nMemoization is a simple yet powerful technique for optimizing performance by caching the results of expensive function calls. By reusing previously computed results, it can significantly speed up applications, especially those that involve recursive or frequently repeated calculations. However, developers should be mindful of memory consumption and cache management when implementing memoization in large-scale applications.",
      "output": "Calculating result for: [5]\n120\nFetching from cache for: [5]\n120\nCalculating result for: [6]\n720"
    },
    {
      "title": "Symbols and Symbol Iterator",
      "fileName": "symbols-iterator",
      "fileType": ".js",
      "code": "// Creating a Symbol\nconst sym1 = Symbol('description');\nconst sym2 = Symbol('description');\n\nconsole.log(sym1 === sym2);  // false\n\n// Using Symbols for Object Properties\nconst person = {\n  name: 'John',\n  [sym1]: 'secret information'\n};\n\nconsole.log(person[sym1]);  // secret information\n\n// Using Symbol.iterator\nconst range = {\n  from: 1,\n  to: 5,\n  [Symbol.iterator]: function() {\n    let current = this.from;\n    let last = this.to;\n    return {\n      next: function() {\n        if (current <= last) {\n          return { value: current++, done: false };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\nfor (let num of range) {\n  console.log(num);  // 1, 2, 3, 4, 5\n}",
      "description": "# Symbols and Symbol.iterator\n**Symbols** are a new primitive data type in JavaScript introduced in ES6. Symbols are unique and immutable values often used to create unique property keys for objects, which prevents accidental name clashes. Symbols are especially useful in situations where you want to ensure property names don't conflict with any other properties on the object.\n\n### Symbols\nA symbol is created by calling the `Symbol()` function. Each time you call `Symbol()`, it returns a new, unique symbol. Even if two symbols have the same description, they are still different symbols:\n\n```js\nconst sym1 = Symbol('description');\nconst sym2 = Symbol('description');\nconsole.log(sym1 === sym2);  // false\n``` \nHere, `sym1` and `sym2` are different symbols despite having the same description.\n\nSymbols are useful for creating properties that are guaranteed not to clash with other properties in the object, especially when you want to hide the implementation details or avoid external interference.\n\nFor example, using a symbol as a property key:\n\n```js\nconst person = {\n  name: 'John',\n  [sym1]: 'secret information'\n};\nconsole.log(person[sym1]);  // secret information\n``` \nThe property keyed by `sym1` is unique and can't be accessed by any other code unless it knows the exact symbol.\n\n### Symbol.iterator\nThe `Symbol.iterator` is a built-in symbol that defines the default iterator for an object. An object must implement the `Symbol.iterator` method to be used in loops like `for...of`. This is commonly used to make custom objects iterable.\n\nHere’s an example of using `Symbol.iterator` to create a custom iterable object:\n\n```js\nconst range = {\n  from: 1,\n  to: 5,\n  [Symbol.iterator]: function() {\n    let current = this.from;\n    let last = this.to;\n    return {\n      next: function() {\n        if (current <= last) {\n          return { value: current++, done: false };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\nfor (let num of range) {\n  console.log(num);  // 1, 2, 3, 4, 5\n}\n``` \nIn this example, the `range` object is made iterable by implementing the `Symbol.iterator` method. The `next()` method is called for each iteration, and the loop continues until `done` is true.\n\n### Conclusion\nSymbols provide a way to create unique identifiers in JavaScript that can be used as object property keys, ensuring no accidental clashes with other properties. The `Symbol.iterator` method is used to make custom objects iterable, giving developers more control over how objects are looped through in `for...of` and similar constructs. These concepts help in creating more secure and flexible code.",
      "output": "false\nsecret information\n1\n2\n3\n4\n5"
    },
    {
      "title": "Decorators",
      "fileName": "decorators",
      "fileType": ".js",
      "code": "// Decorator example using a higher-order function\nfunction logExecution(target, propertyKey, descriptor) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function (...args) {\n    console.log(`Calling ${propertyKey} with`, args);\n    const result = originalMethod.apply(this, args);\n    console.log(`Result: ${result}`);\n    return result;\n  };\n  return descriptor;\n}\n\nclass Calculator {\n  @logExecution\n  add(a, b) {\n    return a + b;\n  }\n}\n\nconst calc = new Calculator();\ncalc.add(5, 3);",
      "description": "# Decorators in JavaScript\n**Decorators** are a special kind of declaration that can be attached to classes, methods, accessors, properties, or parameters. They allow behavior to be modified or enhanced in a declarative way.\n\nThey are similar to annotations or attributes in other languages and are **used to wrap, modify, or observe behavior** at runtime. Currently, decorators are a **Stage 3 ECMAScript proposal** and widely supported in tools like TypeScript and with transpilers like Babel.\n\n## Syntax and Use\nA decorator is simply a function. When used on a method, it receives three arguments:\n- `target`: the prototype of the class\n- `propertyKey`: the name of the method\n- `descriptor`: the property descriptor of the method (from `Object.getOwnPropertyDescriptor`)\n\nThe function can change or return a new descriptor to alter behavior.\n\n### Example: Logging Decorator\nIn the example above, `@logExecution` is a decorator that logs method calls and their results. When applied to the `add` method of the `Calculator` class, it wraps the original function, allowing you to inspect inputs and outputs without modifying the method directly.\n\n```js\n@logExecution\nadd(a, b) {\n  return a + b;\n}\n```\n\n### Decorators on Classes\nYou can also decorate entire classes to inject or extend behaviors — for example, to register metadata or automatically bind methods.\n\n```js\nfunction sealed(constructor) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n\n@sealed\nclass MyClass {\n  // This class is sealed (no new props can be added)\n}\n```\n\n### Where Decorators Are Used\n- **Logging, Metrics, and Analytics**\n- **Memoization and Caching**\n- **Access Control**\n- **Dependency Injection (Angular)**\n- **Validation and Metadata (TypeORM, class-validator)**\n\n### Notes\n- To use decorators today, you need to enable them via TypeScript (`experimentalDecorators`) or Babel with the appropriate plugin.\n- The `@decorator` syntax is sugar for calling a function and passing the relevant metadata.\n\n### Summary\nDecorators offer a powerful way to write clean, expressive code for modifying behavior declaratively. They are particularly useful in class-based designs and frameworks that emphasize annotation (like Angular).",
      "output": "Calling add with [ 5, 3 ]\nResult: 8"
    },
    {
        "title": "Tail Call Optimization (TCO)",
        "fileName": "tail-call-optimization",
        "fileType": ".js",
        "code": "// Non-tail-recursive function (builds up a call stack):\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1); // Not tail-recursive: multiplication happens after the recursive call\n}\n\nconsole.log(\"Factorial (non-TCO):\", factorial(5));\n\n// Tail-recursive version (final result passed through accumulator):\nfunction factorialTCO(n, acc = 1) {\n  if (n === 1) return acc;\n  return factorialTCO(n - 1, n * acc); // Tail position: the recursive call is the last action\n}\n\nconsole.log(\"Factorial (TCO-style):\", factorialTCO(5));",
        "description": "# Tail Call Optimization in JavaScript\n**Tail Call Optimization (TCO)** is a performance optimization in which the JavaScript engine reuses the current function's stack frame for a recursive call — *if* the call is in **tail position**, meaning it's the last action the function performs.\n\n### Why It Matters\n- Helps avoid **stack overflows** in deeply recursive functions.\n- Allows recursion to run in **constant stack space**, similar to iteration.\n\n### Requirements for TCO\n- The recursive call must be in **tail position** — returned directly.\n- The result of the recursive call must not be used after it's made.\n- TCO is supported in **strict mode** in some environments (e.g., Safari), but **not widely** implemented in most JavaScript engines like V8 (Chrome, Node.js).\n\n### Example:\n- `factorial(n)` is *not* tail-optimized: it multiplies *after* the recursive call.\n- `factorialTCO(n, acc)` is tail-optimized: the recursive call is the final step.\n\nWhile native TCO is rare in modern engines, you can write TCO-friendly code or simulate optimization via **trampolines** or convert recursion to iteration manually.",
        "output": "Factorial (non-TCO): 120\nFactorial (TCO-style): 120"
      }
      
  ]
}
